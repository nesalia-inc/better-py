---
title: When Not to Use Functional Programming
description: Situations where FP might not be the best choice
---

# When Not to Use Functional Programming

Better-py provides powerful tools for writing safe, functional code in Python. But like any tool, it's not the right choice for every situation. Understanding when not to use functional programming helps you write code that's both practical and maintainable.

The goal isn't purity for its own sake. The goal is to write clear, correct, maintainable code. Sometimes that means using Maybe and Result. Sometimes it means using simple Python. The art is knowing which approach serves your needs best.

## Simple Scripts and One-Off Code

For simple scripts that won't be maintained long-term, the overhead of functional types might not be worth it. When the script is throwaway code or you're just exploring a problem, simple Python is often more appropriate.

```python
# Simple script - regular Python is fine
def main():
    data = load_data()
    result = process(data)
    save(result)

if __name__ == "__main__":
    main()
```

The script is short, the logic is straightforward, and no one will need to maintain it. Adding Maybe and Result would complicate the code without providing much benefit.

### When FP Is Worth It Even for Scripts

Even simple scripts benefit from functional patterns when they handle external systems or process untrusted input.

```python
# Even simple scripts benefit from safe error handling
def fetch_user(user_id: int) -> Result[dict, str]:
    try:
        response = requests.get(f"{API_URL}/users/{user_id}")
        response.raise_for_status()
        return Result.ok(response.json())
    except requests.RequestException as e:
        return Result.error(f"Failed to fetch user: {e}")
```

The script is still simple, but errors are handled explicitly. If the API call fails, you get a clear error message instead of a stack trace.

## Performance-Critical Inner Loops

In tight loops where performance is absolutely critical, the overhead of wrapping and unwrapping values might matter. If profiling shows that functional code is a bottleneck, consider using direct Python operations in that specific section.

```python
# In a performance-critical loop, direct operations might be faster
def sum_squares(numbers: list[int]) -> int:
    total = 0
    for n in numbers:
        total += n * n
    return total
```

This doesn't mean your entire codebase should abandon functional patterns. It means optimize the specific hot paths that profiling identifies.

### Profile Before Optimizing

Most code is not performance-critical. Don't avoid functional patterns because you're worried about performanceâ€”measure first. You'll often find that the overhead is negligible compared to the actual work being done.

```python
# Probably fine - most code isn't performance-critical
def process_items(items: PersistentList[int]) -> PersistentList[int]:
    return items.map(lambda x: x * 2).filter(lambda x: x > 100)
```

Use functional patterns by default. Only optimize when profiling shows a genuine bottleneck.

## Interfacing with Mutable Libraries

Many Python libraries expect mutable collections and don't provide any way to work with immutable data. Pandas, NumPy, Django ORM, and countless other libraries are designed around mutable data structures.

When working with these libraries, constantly converting between persistent and mutable collections adds complexity without benefit. Use the library's native types and convert only at boundaries.

```python
# Work with the library's conventions
import pandas as pd

def analyze_data(data: PersistentList):
    # Convert once at the boundary
    mutable_list = data.to_list()

    # Use pandas as designed
    df = pd.DataFrame(mutable_list)
    result = df.groupby('category').sum()

    # Convert back if needed
    return PersistentMap.from_dict(result.to_dict())
```

This confines the mutable code to a small scope. Your application code uses persistent collections, while the library integration happens at well-defined boundaries.

### Gradual Integration

When introducing better-py to an existing codebase, you don't have to convert everything at once. Use persistent collections in new code and gradually refactor old code over time.

```python
# New code - use persistent collections
def new_feature(items: PersistentList[int]) -> PersistentList[int]:
    return items.filter(lambda x: x > 0).map(lambda x: x * 2)

# Old code - stays mutable for now
def legacy_feature(items: list) -> list:
    result = []
    for item in items:
        if item > 0:
            result.append(item * 2)
    return result
```

This gradual approach lets you adopt better-py without a massive refactor. Over time, you'll convert more code as you touch it.

## User-Facing APIs and Public Interfaces

When designing a public API, consider whether functional patterns make sense for your users. If your library targets developers unfamiliar with functional programming, traditional Python patterns might be more appropriate.

```python
# Internal implementation - use FP
def _fetch_user(id: int) -> Result[User, FetchError]:
    # Implementation with all the safety benefits
    pass

# Public API - simpler interface
def fetch_user(id: int):
    """Fetch a user or return None if not found.

    Simple interface for users unfamiliar with Result.
    """
    result = _fetch_user(id)
    if result.is_ok():
        return result.unwrap()
    return None
```

This doesn't mean you can't use FP internally. Just convert to a simpler interface at the boundary if that better serves your users.

### Document Both Approaches

If your library uses functional patterns, document both the functional approach and the traditional approach. Let users choose what works for them.

```python
# Functional approach - type-safe and explicit
result = api.fetch_user(123)
if result.is_ok():
    user = result.unwrap()
    process_user(user)
else:
    handle_error(result.unwrap_error())

# Traditional approach - simpler but less safe
user = api.fetch_user_simple(123)
if user is not None:
    process_user(user)
```

Both approaches have their place. Document when to use each.

## Exploratory Programming and Prototyping

When you're exploring a problem space or prototyping a solution, you might not know the right types yet. Forcing yourself to define types upfront can slow down exploration.

```python
# During prototyping - figure out the problem first
def process(data):
    # Experiment with different approaches
    result = transform(data)
    return finalize(result)
```

Once you understand the problem and the design settles, go back and add types. The types will be better because you understand the problem better.

### Add Types When Design Stabilizes

Functional patterns shine when the design is stable. During exploration, flexibility matters more than type safety.

```python
# Exploration phase - flexible and fast
def experiment(data):
    # Try different transformations
    for transform in [transform_a, transform_b, transform_c]:
        result = transform(data)
        if is_valid(result):
            return result
    return None

# Production phase - safe and typed
def process(data: dict) -> Result[ProcessedData, ProcessError]:
    return (
        validate_input(data)
        .bind(transform_a)
        .bind(transform_b)
        .bind(finalize)
    )
```

Use flexibility during exploration, then add safety for production.

## Test Code

Test code doesn't always need the same level of type safety as production code. The tests themselves catch errors, and the focus is on clarity rather than safety.

```python
# Test code - simpler is often better
def test_fetch_user():
    result = fetch_user(123)
    assert result.is_ok()
    assert result.unwrap()["name"] == "Alice"
```

That said, types in tests can serve as documentation, showing users how to use your APIs. Balance clarity with brevity.

## Legacy Codebases

When working with a large legacy codebase that uses mutable collections everywhere, trying to convert everything to immutable at once is overwhelming. Focus on new code and gradually refactor old code as you touch it.

```python
# New module - use persistent collections
from better_py import PersistentList, PersistentMap

class NewService:
    def __init__(self):
        self.users = PersistentMap.empty()
        self.audit_log = PersistentList.empty()

# Old module - leave it mutable for now
class OldService:
    def __init__(self):
        self.users = {}
        self.audit_log = []
```

Over time, you'll convert more modules. Better-py is designed to coexist with regular Python code, so you can adopt it incrementally.

## Data Science and Numerical Computing

Data science and numerical computing libraries like NumPy, Pandas, and TensorFlow are designed around mutable arrays and dataframes. These libraries are highly optimized, and wrapping everything in persistent collections would negate their performance benefits.

```python
# Use data science libraries as designed
import pandas as pd

def analyze(df: pd.DataFrame) -> pd.DataFrame:
    # Mutate the dataframe - this is how pandas is designed
    df['new_column'] = df['old_column'] * 2
    return df.groupby('category').sum()
```

That doesn't mean you can't use better-py in data science applications. Use persistent collections for application logic, configuration, and state management. Use mutable arrays for the actual numerical computations.

<Callout type="info" title="Pragmatic Functional Programming">

Functional programming is a tool, not a religion. Use better-py where it provides clarity and safety: business logic, error handling, state management, and application code. Use regular Python where it's more practical: scripts, performance-critical code, data science, and library integration.

The best code uses the right tool for each situation, not dogmatically applies one approach everywhere.

</Callout>

## Making the Decision

When deciding whether to use functional patterns, ask yourself:

- **Will this code be maintained long-term?** If yes, types and immutability help.
- **Is error handling important?** If yes, Result and Maybe provide value.
- **Is this a hot path identified by profiling?** If yes, optimize with simple Python.
- **Am I interfacing with a mutable library?** If yes, use its conventions.
- **Is this exploratory or throwaway code?** If yes, keep it simple.

There's no single answer. The right choice depends on your specific situation. Trust your judgment, and don't be afraid to mix approaches when it makes sense.

<Callout type="success" title="Remember: Progress Over Purity">

You don't have to be purely functional to benefit from better-py. Use it where it helps, use regular Python where it doesn't. The goal is better code, not functional purity.

</Callout>

<Callout type="info" title="See More Examples">

- [Best Practices Overview](/docs/best-practices) - Recommended patterns for better-py
- [Anti-Patterns](/docs/best-practices/anti-patterns) - Common mistakes to avoid
- [Performance Guide](/docs/best-practices/performance) - Performance considerations

</Callout>
