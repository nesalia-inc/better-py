---
title: Error Messages Best Practices
description: Write clear, actionable error messages
---

# Error Messages Best Practices

Error messages are your primary communication channel with users when something goes wrong. A good error message transforms a frustrating debugging session into a quick fix. A bad error message leaves users confused, frustrated, and guessing what went wrong.

The difference between a good error message and a bad one isn't just politeness—it's about providing enough context for users to understand the problem and take action. Every error message should answer three questions: What went wrong? Why did it go wrong? What can the user do about it?

## What Makes a Good Error Message

Good error messages are specific, actionable, and contextual. They don't just say something failed—they explain what failed, why it failed, and what the user can do to fix it. This turns errors from roadblocks into signposts.

Consider the difference between these two error messages:

```python
# Bad - Vague and unhelpful
return Result.error("Validation failed")

# Good - Specific and actionable
return Result.error("Email 'invalid-at-sign' is invalid: missing @ symbol")
```

The first message tells you something went wrong, but not what or why. The second message identifies the problematic value, explains what's wrong with it, and implicitly tells you how to fix it.

Good error messages also consider the audience. Internal errors shown to developers can include technical details, stack traces, and debugging information. Errors shown to end users should be friendly and avoid jargon while still being specific enough to be useful.

## Be Specific About What Failed

Vague error messages force users to investigate the code to understand what went wrong. Specific messages tell them exactly what the problem is.

```python
# Bad - What user?
return Result.error("User not found")

# Good - Identifies which user
return Result.error(f"User with ID {user_id} not found in database")
```

The specific version tells you exactly which user was missing. This is crucial when debugging—you can immediately check the database for that user ID, verify the input, or identify a data inconsistency.

Specificity is especially important when dealing with external systems. When an API call fails, include the URL, status code, and relevant request parameters. When a file operation fails, include the file path and the operation being performed.

```python
# Good - Includes all relevant details
return Result.error(
    f"Failed to fetch user from API: "
    f"URL={url}, Status={response.status_code}, "
    f"Response={response.text[:100]}"
)
```

This level of detail makes debugging dramatically easier. You don't have to add logging to figure out what's failing—the error message tells you everything you need to know.

## Provide Context About Why It Failed

Knowing what failed is only half the battle. Knowing why it failed helps users understand the root cause and prevent similar issues in the future.

```python
# Bad - Doesn't explain why
return Result.error("Failed to save user to database")

# Good - Explains the reason
return Result.error(
    f"Failed to save user '{user_id}': "
    f"Database constraint violation - email '{email}' already exists"
)
```

The second message tells you not just that the save failed, but why: there's a duplicate email. This is a completely different problem than, say, a network timeout or a permission error, each requiring a different solution.

Context is especially important for validation errors. Instead of saying a value is "invalid," explain what rule it violated:

```python
# Bad - Vague validation
return Result.error("Invalid password")

# Good - Explains the validation rule
return Result.error(
    f"Password does not meet security requirements: "
    f"must be at least 12 characters, include uppercase, "
    f"lowercase, number, and special character"
)
```

Now the user knows exactly what's required and can fix the password accordingly.

## Suggest Solutions or Next Steps

The best error messages don't just identify problems—they point toward solutions. This transforms an error from a dead end into a detour sign.

```python
# Bad - Leaves user stuck
return Result.error("API key not found")

# Good - Tells user how to fix it
return Result.error(
    "API key not found. Set the API_KEY environment variable, "
    "or pass api_key parameter to authenticate(). "
    "Get your API key at https://example.com/signup"
)
```

The second message gives the user multiple paths forward: set an environment variable, pass a parameter, or sign up for a key. Even if they've never used your library before, they know exactly what to do.

Suggested solutions are particularly valuable for configuration errors. Users might be setting up your library for the first time and don't know what's expected:

```python
# Good - Guides first-time setup
return Result.error(
    "Database connection failed. Check that: "
    "1) DATABASE_URL is set (current value: None) "
    "2) The database server is running "
    "3) Network connectivity to the database exists "
    "\nExample: DATABASE_URL=postgresql://localhost:5432/mydb"
)
```

This checklist approach helps users systematically diagnose and fix the problem.

## Consider Your Audience

Error messages should be tailored to who will see them. Developer-facing errors can be technical and detailed. User-facing errors should be friendly and avoid implementation details.

```python
# Developer-facing error - technical and detailed
return Result.error(
    f"ForeignKeyConstraint violated: "
    f"table={table}, column={column}, "
    f"key={key_value} does not exist in referenced table {ref_table}"
)

# User-facing error - friendly and simple
return Result.error(
    "Unable to delete this category because it still contains products. "
    "Move or delete the products first, then try again."
)
```

The developer error includes database terminology and exact details needed for debugging. The user error abstracts away the database details and focuses on what the user needs to do.

When writing library code, remember that both developers and end users might see your errors. Consider providing separate error messages for internal versus external consumption, or structure your error types to make it easy to present appropriate messages to each audience.

## Include Relevant Values

When an error involves specific values, include those values in the error message. This saves users from adding debug logging just to see what's failing.

```python
# Bad - Hides the problematic value
return Result.error("Invalid port number")

# Good - Shows what was provided
return Result.error(
    f"Invalid port number '{port}': "
    f"must be between 1 and 65535, got {port}"
)
```

Now you can immediately see if the user passed 0, -1, 70000, or "localhost"—all common mistakes with different root causes.

Be careful about including sensitive information in error messages. Passwords, API keys, tokens, and personal data should never appear verbatim in error messages:

```python
# Bad - Leaks sensitive data
return Result.error(f"Authentication failed: password='{password}'")

# Good - Protects sensitive data
return Result.error(
    f"Authentication failed for user '{username}': "
    f"incorrect password (length: {len(password)} characters)"
)
```

Show the length or format of sensitive data if it helps debugging, but never the actual value.

## Structure Errors for Machine Parsing

When designing error types for your application, structure them so they can be parsed and handled programmatically. String error messages are great for humans, but error types are better for code.

```python
from dataclasses import dataclass
from better_py import Result

@dataclass(frozen=True)
class ValidationError:
    field: str
    message: str
    value: str

def validate_email(email: str) -> Result[str, ValidationError]:
    if "@" not in email:
        return Result.error(ValidationError(
            field="email",
            message="missing @ symbol",
            value=email
        ))
    return Result.ok(email)
```

Now code that calls this function can inspect the error type and handle specific cases differently, while still being able to display a human-readable message to users.

<Callout type="success" title="Error Message Checklist">

Every error message should:
- **Identify what failed** (which user, which file, which operation)
- **Explain why it failed** (validation rule, constraint, technical reason)
- **Suggest a solution** (configuration change, code fix, user action)
- **Include relevant values** (what was passed, what was expected)
- **Respect the audience** (technical for developers, simple for users)

</Callout>

## Testing Error Messages

Error messages are code, and like all code, they should be tested. Don't just test the happy path—test that error messages are clear and helpful when things go wrong.

```python
def test_error_messages():
    result = validate_email("invalid-at-sign")
    assert result.is_error()

    error = result.unwrap_error()
    assert "email" in str(error).lower()
    assert "@" in str(error)
    assert "invalid-at-sign" in str(error)
```

This test verifies that the error message includes the field name, the validation rule, and the problematic value. When you change the validation logic, this test ensures the error message stays useful.

## Putting It All Together

Good error messages transform user experience. What could be a frustrating support request or a confusing debugging session becomes a quick fix. The extra time spent crafting clear, specific, actionable error messages pays dividends in reduced support burden and happier users.

Remember that error messages are part of your API. Users depend on them to understand how to use your code correctly. An unclear error message is a bug in your API just as much as a bug in your logic.

The next time you write `Result.error("something failed")`, pause and ask yourself: Would this message help me fix the problem if I encountered it in production? If not, add the details that would make it useful.

<Callout type="info" title="See More Examples">

- [Error Handling Guide](/docs/guides/error-handling) - Practical error handling strategies
- [Result Monad](/docs/monads/result) - Learn how to structure error handling
- [Validation Patterns](/docs/monads/validation) - Accumulating and displaying validation errors

</Callout>
