---
title: Core Concepts
description: Understand the fundamental concepts of functional programming with better-py
---

import { BookOpen, Layers, Shield, Zap } from 'lucide-react';

# Core Concepts

This section introduces the fundamental concepts that power better-py. Whether you're new to functional programming or coming from other languages, understanding these concepts will transform how you think about writing code.

Functional programming isn't just a different set of tools. It's a different way of thinking about problems. Instead of telling the computer how to do things step-by-step, you describe what you want to accomplish, and the language handles the details. This shift in perspective leads to code that's more predictable, easier to test, and less prone to bugs.

<Cards>
  <Card
    icon={<BookOpen />}
    title="Functional Programming"
    href="/docs/concepts/what-is-functional-programming"
    description="Learn what functional programming is and why it matters"
  />
  <Card
    icon={<Layers />}
    title="Monads"
    href="/docs/concepts/monads"
    description="Understand monads - the building blocks of functional programming"
  />
  <Card
    icon={<Shield />}
    title="Immutability"
    href="/docs/concepts/immutability"
    description="Why immutable data leads to safer, more predictable code"
  />
  <Card
    icon={<Zap />}
    title="Type Safety"
    href="/docs/concepts/type-safety"
    description="Leverage Python's type system for correctness"
  />
</Cards>

## What You'll Gain

Learning functional programming concepts pays dividends immediately. Your code becomes safer because you eliminate entire classes of bugs related to unexpected state changes. Error handling becomes explicit and predictable, so you're never caught off guard by exceptions. Operations compose cleanly, letting you build complex behavior from simple pieces. And throughout it all, Python's type system works with you to catch mistakes before they become runtime errors.

These concepts work together to form a coherent approach to writing software. When you understand the foundations, everything else falls into place naturally.

## The Core Ideas

Functional programming rests on a few simple ideas that build on each other. First, pure functions always produce the same output for the same input and don't have side effects. This makes them predictable and easy to reason about. Second, immutable data means values never change after creation. Instead of modifying existing data, you create new data with the desired changes. Third, composition lets you build complex behavior from simple functions by combining them like building blocks.

<Callout type="info" title="The Essence of Functional Programming">

At its core, functional programming is about pure functions and immutable data. Pure functions don't modify external state or rely on it. They simply take input and produce output, making them predictable and easy to test. Immutable data means once you create a value, it never changes. This eliminates bugs caused by unexpected modifications and makes your code easier to understand.

</Callout>

## Monads: Structuring Computation

Monads are design patterns that structure how computations work. Think of them as containers with rules about how you can interact with what's inside. The Maybe monad, for example, represents a value that might exist or might not. The Result monad represents a computation that succeeded or failed. These containers let you chain operations together safely, handling all the edge cases automatically.

When you work with monads, you don't have to constantly check for errors or missing values. The monad handles that for you, letting you focus on the happy path while ensuring errors are handled properly.

```python
from better_py import Maybe

# Maybe is a container that might have a value
value = Maybe.some(42)

# Transform the value safely
doubled = value.map(lambda x: x * 2)

# Chain operations that might fail
result = (
    Maybe.some(10)
    .map(lambda x: x * 2)
    .bind(lambda x: Maybe.some(x) if x > 15 else Maybe.nothing())
)
```

## Immutability: Predictable by Design

Immutable data means data never changes after you create it. If you need to modify something, you create a new version with the changes instead. This seems inefficient at first, but persistent data structures use structural sharing to make it fast. When you "modify" an immutable list, the new version shares most of its structure with the original, only allocating memory for what changed.

This approach eliminates entire classes of bugs. You never have to wonder who modified a list or when a value changed. Every piece of data stays exactly as you created it, making your code easier to understand and debug.

```python
from better_py import PersistentList

# Create immutable list
lst1 = PersistentList.of(1, 2, 3)

# "Modify" returns new list
lst2 = lst1.append(4)

# Original unchanged!
assert lst1.to_list() == [1, 2, 3]
assert lst2.to_list() == [1, 2, 3, 4]
```

## Type Safety: Correctness by Design

Python's type system and better-py work together to catch errors before you run your code. Generic types track how data transforms through your program, ensuring that operations that don't make sense are caught by the type checker instead of surfacing as runtime errors.

When you annotate your code properly, your IDE becomes a powerful assistant. It can autocomplete method calls accurately, catch type mismatches, and help you refactor with confidence. The type system documents your code while simultaneously verifying its correctness.

```python
from better_py import Result

def divide(a: int, b: int) -> Result[int, str]:
    if b == 0:
        return Result.error("Division by zero")
    return Result.ok(a // b)

# Type checker knows the result type
result: Result[int, str] = divide(10, 2)
```

## Learning Path

These concepts build on each other, so we recommend learning them in order. Start with functional programming fundamentals to understand the philosophy. Then learn about monads, which are the primary abstraction you'll work with. Immutability shows you why persistent data structures matter, and type safety demonstrates how to leverage Python's type system. Finally, protocols and functional entities show you how to extend and use these patterns effectively.

Start with the functional programming overview to get the big picture, then dive into monads to see how these ideas work in practice.

## What Makes This Approach Different

Traditional imperative programming focuses on how to solve problems step by step. You tell the computer what to do, and in what order. This is intuitive for simple tasks but becomes unwieldy as complexity grows. Functional programming focuses on what you want to accomplish. You describe the transformations and relationships, and the language handles the execution details.

The difference becomes clear when you compare code side by side. The imperative version is full of temporary variables, loops, and error handling. The functional version reads like a description of the problem itself. This clarity is what makes functional programming powerful.

<Callout type="success" title="Where Functional Programming Shines">

Functional programming excels at data processing pipelines, error handling, async operations, state management, and business logic with complex rules. These are all situations where clarity and correctness matter more than micro-optimizations.

</Callout>

<Callout type="warning" title="When to Use Other Approaches">

For simple scripts, performance-critical inner loops, direct hardware interaction, or quick prototypes, functional programming might be overkill. Use good judgment and choose the right tool for the job.

</Callout>

## Key Principles to Remember

Three principles guide everything in better-py. First, make things explicit rather than implicit. If a value might be missing, use Maybe to make that possibility visible in the type system. If an operation can fail, use Result to make the error explicit. Second, prefer immutable data over mutable data. This eliminates surprising behavior and makes code easier to understand. Third, compose operations rather than nest them. Method chaining reads naturally and makes the flow of data clear.

These principles work together to produce code that's both easier to write and easier to maintain. You'll find yourself writing correct code the first time more often, spending less time debugging, and feeling more confident in your changes.

## Ready to Dive Deeper?

Now that you have the overview, choose your next step. If you're new to functional programming, start with the functional programming guide. If you want to get straight to practical usage, jump to the monads documentation. Or read about immutability to understand why persistent data structures are so powerful.

<Cards>
  <Card
    title="Monads Guide"
    href="/docs/concepts/monads"
    description="Deep dive into monads and how they work"
  />
  <Card
    title="Immutability"
    href="/docs/concepts/immutability"
    description="Learn why immutability matters"
  />
  <Card
    title="Type Safety"
    href="/docs/concepts/type-safety"
    description="Master Python's type system"
  />
  <Card
    title="Quick Start"
    href="/docs/getting-started/quick-start"
    description="Build your first functional program"
  />
</Cards>
