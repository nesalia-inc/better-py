---
title: Type Safety
description: Leverage Python's type system for correctness
---

# Type Safety

Python's type system is a powerful tool for writing correct code. Better-py is built with types from the ground up, using generics to track how data flows through your program and catch errors before they become runtime bugs.

Type safety means the type system guarantees that operations on values are appropriate. You can't accidentally treat a string as a number or call a method that doesn't exist. The type checker catches these mistakes before your code ever runs, turning runtime errors into compile-time errors that are fixed immediately.

## Why Type Safety Matters

The immediate benefit of type safety is catching errors early. Without types, you might not discover a bug until a particular code path executes in production. With types, the type checker finds the bug as soon as you write it. This feedback loop is dramatically faster and less frustrating than debugging runtime errors.

Types also serve as documentation. Function signatures tell you what types they accept and return. You don't have to read the implementation or hope the documentation is accurate. The signature is the documentation, and it's guaranteed to be up to date.

```python
from better_py import Result

# Type checker knows the types
def divide(a: int, b: int) -> Result[int, str]:
    if b == 0:
        return Result.error("Division by zero")
    return Result.ok(a // b)

# Type error caught at compile time!
result: Result[int, str] = divide(10, 2)

# Type error - wrong type
value: Result[str, str] = divide(10, 2)  # Error!
```

Better IDE support is another major benefit. When your code is properly typed, your IDE knows exactly what methods and properties are available on each value. Autocomplete becomes accurate instead of suggesting methods that don't exist or will crash at runtime.

## Generic Types in Better-py

All better-py types are fully generic, meaning they work with any type while preserving type information. Maybe[T] wraps a value of type T. Result[T, E] contains either a success value of type T or an error of type E. PersistentList[T] is a list of values of type T.

The type parameter tracks what's inside the wrapper, and the type system propagates this information through your code. When you transform a Maybe[int] with a function that returns a string, the type system knows the result is Maybe[str], not Maybe[int] or Maybe[anything].

```python
from better_py import Maybe, Result, PersistentList

# Maybe[T] tracks the inner type
maybe_int: Maybe[int] = Maybe.some(42)
maybe_str: Maybe[str] = Maybe.some("hello")

# Result[T, E] tracks success and error types
result_ok: Result[int, str] = Result.ok(42)
result_error: Result[int, str] = Result.error("failed")

# PersistentList[T] tracks element type
list_int: PersistentList[int] = PersistentList.of(1, 2, 3)
list_str: PersistentList[str] = PersistentList.of("a", "b", "c")
```

## Type Transformations

The type system tracks transformations as data flows through your code. When you map a Maybe[int] with a function that converts int to str, the type checker knows the result is Maybe[str]. When you map a PersistentList[int] with a function that multiplies by two, the type checker knows the result is still a PersistentList[int].

This tracking happens automatically. You don't have to manually specify intermediate types. The type system infers them from the operations you're performing, making your code concise while maintaining full type safety.

```python
from better_py import Maybe

# Type: Maybe[int]
maybe_int = Maybe.some(42)

# map transforms int -> str
# Type: Maybe[str]
maybe_str = maybe_int.map(str)

# bind transforms Maybe[str] -> Maybe[int]
# Type: Maybe[int]
maybe_back = maybe_str.bind(lambda s: Maybe.some(len(s)))
```

Result types track both success and error transformations independently. Map transforms the success type while preserving the error type. Map_error transforms the error type while preserving the success type. This lets you handle errors appropriately without losing type information.

```python
from better_py import Result

# Type: Result[int, str]
result: Result[int, str] = Result.ok(42)

# map transforms int -> str
# Type: Result[str, str]
mapped = result.map(lambda x: str(x))

# map_error transforms str -> int
# Type: Result[str, int]
error_mapped = mapped.map_error(lambda e: len(e))
```

## Type Inference

Python's type inference works well with better-py, often eliminating the need for explicit type annotations. When you create a Maybe with Maybe.some(42), the type system infers Maybe[int]. When you call methods on it, the type system tracks the transformations.

This inference makes code concise without sacrificing type safety. You only need to annotate function signatures and occasionally ambiguous expressions. The type system fills in the rest, making type checking feel lightweight rather than burdensome.

```python
from better_py import Maybe

# Type inferred as Maybe[int]
result = Maybe.some(42)

# Function infers types from usage
def process(value: Maybe[int]) -> int:
    return value.map(lambda x: x * 2).unwrap_or(0)
```

## Configuring Mypy

Mypy is Python's standard type checker, and it works excellently with better-py. A basic configuration catches most type errors while remaining practical for real-world code.

Enable strict mode for maximum safety. This mode turns on all optional checks, catching issues you might not even know existed. The trade-off is that you need to be more diligent about typing everything, but the payoff is worth it for most projects.

```ini
# mypy.ini
[mypy]
python_version = 3.11
strict = True
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
```

Run mypy regularly as part of your development workflow. Many IDEs run it automatically in the background, showing type errors inline. You can also run it manually or in CI to catch type errors before they're merged.

```bash
# Check all files
mypy .

# Check specific file
mypy src/main.py

# Strict mode
mypy --strict src/
```

## Type-Safe Error Handling

Type safety transforms error handling from a source of bugs into a guaranteed property of your code. When you use Result to represent errors, the type system forces you to handle both success and error cases. You can't accidentally use an error value as if it were a success value.

Define specific error types for different failure modes. Instead of a generic Exception or str, use a union of specific error types. The type system then tracks exactly what errors each operation can produce, forcing you to handle all of them appropriately.

```python
from better_py import Result

# Define error types
class DatabaseError(Exception):
    pass

class ValidationError(Exception):
    pass

# Result with specific error type
def fetch_user(id: int) -> Result[User, DatabaseError | ValidationError]:
    if id < 0:
        return Result.error(ValidationError("Invalid ID"))
    try:
        user = db.query(id)
        return Result.ok(user)
    except Exception as e:
        return Result.error(DatabaseError(str(e)))
```

Type narrowing works seamlessly with Result. When you check result.is_ok(), the type system knows that within the if branch, the result contains a success value. Within the else branch, it contains an error value. This narrowing is automatic and makes error handling code both safe and concise.

```python
from better_py import Result

def process_result(result: Result[int, str]) -> int:
    # Type narrowing
    if result.is_ok():
        # Type is narrowed to int
        return result.unwrap() * 2
    else:
        # Type is narrowed to str
        print(f"Error: {result.unwrap_error()}")
        return 0
```

## Type-Safe Collections

Persistent collections preserve type information just like monads do. When you create a PersistentList[int], the type system knows it contains integers. Map transforms it to PersistentList[str] if the function returns strings. Filter preserves the type because it only removes elements, doesn't transform them.

This type tracking makes collections safe to use. You can't accidentally treat a list of strings as a list of numbers. The type checker catches type mismatches immediately, preventing runtime errors.

```python
from better_py import PersistentList

# Type: PersistentList[int]
numbers = PersistentList.of(1, 2, 3)

# map transforms types
# Type: PersistentList[str]
strings = numbers.map(str)

# filter preserves type
# Type: PersistentList[int]
evens = numbers.filter(lambda x: x % 2 == 0)
```

PersistentMap tracks both key and value types independently. Map_values transforms the value type while preserving the key type. This means you can transform values safely, knowing that the type system will catch any mismatches.

```python
from better_py import PersistentMap

# Type: PersistentMap[str, int]
ages = PersistentMap({"Alice": 30, "Bob": 25})

# map_values transforms value type
# Type: PersistentMap[str, str]
descriptions = ages.map_values(lambda age: f"{age} years old")
```

## Common Type Patterns

Type aliases make complex types readable and reusable. Instead of repeating Result[User, str] throughout your code, define a type alias like FetchUserResult. This makes code more self-documenting and easier to refactor.

```python
from better_py import Result

# Create reusable type aliases
UserId = int
User = dict
FetchUserResult = Result[User, str]

def fetch_user(id: UserId) -> FetchUserResult:
    # Implementation
    pass
```

Generic classes let you write type-safe reusable components. When you define a class with type parameters, the type system ensures consistency across all uses of that class. This is particularly powerful for repositories, services, and other components that work with multiple entity types.

```python
from better_py import Maybe, Result

class Repository[T]:
    def get(self, id: int) -> Maybe[T]:
        # Implementation
        pass

    def save(self, item: T) -> Result[T, str]:
        # Implementation
        pass

# Usage with specific types
user_repo: Repository[User] = Repository()
product_repo: Repository[Product] = Repository()
```

## Best Practices

Always annotate public APIs. The signature is the first thing users see, and types make it self-documenting. Users don't have to read the implementation or guess what types to use. The type checker guides them.

```python
# Good - explicit types
def fetch_user(id: int) -> Maybe[User]:
    # Implementation
    pass

# Bad - no type hints
def fetch_user(id):
    # Implementation
    pass
```

Use specific error types instead of generic ones. Instead of Result[T, Exception], use Result[T, DatabaseError | ValidationError]. Specific types force you to handle each error appropriately and make error handling code more explicit.

```python
# Good - specific error type
def divide(a: int, b: int) -> Result[float, DivisionError]:
    # Implementation
    pass

# Bad - generic error type
def divide(a: int, b: int) -> Result[float, Exception]:
    # Implementation
    pass
```

Leverage type inference where it makes sense. You don't need to annotate every expression. Let mypy infer intermediate types, and annotate only where the type is ambiguous or serves as documentation.

```python
# Good - let mypy infer
result = Maybe.some(42).map(lambda x: x * 2)

# Unnecessary - explicit annotation
result: Maybe[int] = Maybe.some(42).map(lambda x: x * 2)
```

<Callout type="info" title="Type Safety and Better-py Work Together">

The type system and better-py's design reinforce each other. Monads make optionality and errors explicit in types, which the type checker then verifies. Persistent collections track element types through transformations. Protocols define interfaces that the type checker enforces. This synergy catches entire categories of bugs before runtime.

</Callout>

## Strict Type Checking

Enable strict mode for maximum safety. This mode catches issues that regular type checking misses, like missing return statements, unused variables, implicit Any types, and incompatible return types. The initial effort to fix all strict mode errors pays off quickly in reduced bugs and increased confidence.

```bash
mypy --strict your_project/
```

Strict mode requires discipline. Every function needs a return type. Every variable needs a type or initializer. Every error case needs to be handled. But this discipline is exactly what produces reliable code. The type checker becomes a partner that catches mistakes you might miss, not an obstacle to work around.

## Common Mistakes

When working with types in better-py, certain mistakes can undermine the safety and clarity that types are meant to provide. Being aware of these pitfalls helps you get the full benefit of the type system.

### Mistake 1: Using Any Too Liberally

The `Any` type turns off type checking entirely. When you use `Any`, the type checker assumes you know what you're doing and won't verify any operations on that value.

```python
# DON'T - Defeats type checking
def process_data(data: Any) -> Any:
    return data.transform()  # Type checker won't catch if this is wrong

# DO - Use specific types
def process_data(data: dict) -> dict:
    return data  # Type checker knows what's happening
```

Every use of `Any` is a hole in your type safety net. Use specific types whenever possible. Only use `Any` when you're truly working with data of unknown structure, like parsing arbitrary JSON.

### Mistake 2: Ignoring Type Checker Errors

It's tempting to add `# type: ignore` comments to make type checker errors go away, especially when you're refactoring or working with legacy code. But these comments disable type safety for specific lines, which can hide real bugs.

```python
# DON'T - Silences the type checker
result = api_call()  # type: ignore

# DO - Fix the underlying issue
result: Result[User, str] = api_call()
```

If you must use `# type: ignore`, add an explanation why. This helps future maintainers (including your future self) understand why the type checker is being suppressed.

```python
result = legacy_function()  # type: ignore - legacy code, will refactor
```

### Mistake 3: Not Annotating Public APIs

Public interfaces are where type annotations matter most. Even if your internal code isn't fully typed, your public APIs should always have complete type annotations.

```python
# DON'T - Users have to guess the types
def fetch_user(id):
    # Implementation
    pass

# DO - Types serve as documentation
def fetch_user(id: int) -> Result[User, FetchError]:
    # Implementation
    pass
```

Users of your library shouldn't have to read the implementation to know what types to pass and expect. The signature should be self-documenting.

### Mistake 4: Over-Using Type Aliases

Type aliases are useful for readability, but over-using them can make code harder to follow. When every type is an alias, readers have to jump to definition after definition to understand what's happening.

```python
# DON'T - Hard to follow
UserId = int
UserName = str
UserEmail = str
UserData = tuple[UserId, UserName, UserEmail]

def process(user: UserData) -> UserId:
    return user[0]

# DO - Clearer with direct types
def process(user: tuple[int, str, str]) -> int:
    return user[0]
```

Use type aliases for complex or repeated types. Skip them for simple cases where the type is obvious.

### Mistake 5: Forgetting Return Types

Python allows you to omit return type annotations, but this makes your code less clear and prevents the type checker from verifying that all code paths return a value.

```python
# DON'T - No return type
def process_user(id: int):
    if id > 0:
        return find_user(id)

# DO - Explicit return type
def process_user(id: int) -> Maybe[User]:
    if id > 0:
        return find_user(id)
    return Maybe.nothing()
```

The first version has a bug: if `id <= 0`, the function implicitly returns `None`, which might not be what callers expect. The second version makes the return type explicit and handles all cases.

## When NOT to Worry About Types

Type safety is powerful, but it's not always the right priority. Understanding when to relax strict typing helps you ship code faster without sacrificing quality where it matters.

### Prototyping and Exploration

When you're exploring a problem space or prototyping a solution, strict types can slow you down. You might not know the right types yet, and that's okay. Focus on understanding the problem first, then add types once the design is clear.

```python
# During prototyping - types can wait
def process(data):
    # Explore the solution space
    result = transform(data)
    return finalize(result)
```

Once the design is settled, go back and add types. The types will be better because you understand the problem better.

### Simple Scripts and Glue Code

For simple scripts that won't be maintained long-term, or glue code that connects two well-typed components, full type annotations might be overkill.

```python
# Simple one-off script
def main():
    data = load_data()
    result = process(data)
    save(result)

if __name__ == "__main__":
    main()
```

Use your judgment. If the script is complex enough that you'll need to maintain it, add types. If it's truly throwaway code, keep it simple.

### Test Code

Test code doesn't always need the same level of type safety as production code. The tests themselves catch type errors, and the focus is on clarity and maintainability rather than type safety.

```python
# Test code - simpler is often better
def test_fetch_user():
    result = fetch_user(123)
    assert result.is_ok()
    assert result.unwrap()["name"] == "Alice"
```

That said, types in tests can serve as documentation, showing users how to use your APIs. Balance clarity with brevity.

### Performance-Critical Inner Loops

In rare cases, type checking can slow down development cycles. If you're iterating on a performance-critical section and type checking is slowing your edit-run cycle, it's okay to temporarily exclude that file from type checking.

```bash
# Exclude hot files temporarily
mypy --exclude '(benchmark|perf_test)' src/
```

Just remember to re-enable type checking once you're done optimizing. The long-term benefits of type safety outweigh short-term iteration speed.

<Callout type="warning" title="Pragmatism Over Purity">

Types are a tool to help you write correct code, not a goal in themselves. Focus on types where they provide the most value: public APIs, complex logic, and long-lived code. Relax in areas where the benefit doesn't justify the cost.

</Callout>

## The Payoff

Type safety transforms how you write and maintain code. Refactoring becomes less scary because the type checker tells you exactly what breaks. Adding features becomes faster because autocomplete guides you. Bugs become rarer because the type system catches mistakes before they run.

The investment in types pays dividends throughout the lifetime of a project. Code with good types is easier to understand, easier to modify, and less prone to bugs. New contributors can understand the codebase faster because types serve as documentation. Refactors that would be terrifying without types become routine.

Ready to leverage types effectively? The API reference shows all the type signatures, and the examples demonstrate how to write type-safe functional code in Python.
