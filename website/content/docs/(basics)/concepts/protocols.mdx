---
title: Protocols
description: Type-safe protocols for extensible design
---

# Protocols

Protocols in better-py provide a way to define type-safe interfaces that work across different types. They enable polymorphism and extensibility while maintaining complete type safety. Instead of rigid inheritance hierarchies, protocols let you define capabilities that any type can implement.

The power of protocols is that they're structural. A type satisfies a protocol if it has the required methods, regardless of whether it explicitly declares the protocol. This is called duck typing, but with the type system verifying that the duck actually quacks.

## What Are Protocols?

Protocols are structural types that define interfaces. When you define a protocol, you specify the methods that a type must have to satisfy that protocol. Any type with those methods satisfies the protocol, whether or not it explicitly declares it.

This is different from inheritance-based interfaces. With inheritance, a type must explicitly inherit from an interface. With protocols, the type just needs to have the right methods. This makes your code more flexible and less coupled to specific types.

```python
from better_py.protocols import Mappable

# Any type with map method satisfies Mappable
class MyContainer:
    def map(self, fn):
        # Implementation
        pass

# MyContainer is a Mappable!
def process[T: Mappable](container: T) -> T:
    return container.map(lambda x: x * 2)
```

The type system verifies that the type actually satisfies the protocol. You can't accidentally use a type that doesn't have the required methods. This gives you the flexibility of duck typing with the safety of static typing.

## Why Protocols Matter

Protocols enable code that works with any compatible type. Instead of writing functions that only work with PersistentList, you write functions that work with anything that's reducible. The function becomes more general and reusable.

This flexibility doesn't come at the cost of type safety. The type system still verifies that the operations you perform are valid. You get the best of both worlds: flexible code that's also type-safe.

```python
from better_py.protocols import Reducible

def sum_all[T: Reducible](items: T) -> int:
    return items.reduce(lambda acc, x: acc + x, 0)

# Works with PersistentList
sum_all(PersistentList.of(1, 2, 3))  # 6

# Works with regular list
sum_all([1, 2, 3])  # 6

# Works with any custom Reducible
```

Protocols also enable composition. You can require that a type satisfies multiple protocols, combining capabilities in flexible ways. A type might be both Mappable and Reducible, and your code can take advantage of both capabilities.

```python
from better_py.protocols import Mappable, Reducible

def process[T: (Mappable, Reducible)](data: T) -> float:
    return (
        data.map(lambda x: x * 2)
        .reduce(lambda acc, x: acc + x, 0)
    ) / len(data)
```

## Core Protocols in Better-py

Better-py provides a set of core protocols that capture common patterns. These protocols are implemented by better-py's types, and you can also implement them in your own types.

Mappable types support a map operation that transforms each element. Maybe, Result, and PersistentList are all mappable. Any type with a map method that applies a function to its contents can be mappable.

```python
from better_py.protocols import Mappable

# Mappable transforms elements
protocol Mappable[T]:
    def map[U](self, fn: Callable[[T], U]) -> Mappable[U]:
        """Transform each element"""
        pass
```

Reducible types support a reduce operation that combines elements into a single value. All the persistent collections implement this protocol, as do Python's built-in collections.

```python
from better_py.protocols import Reducible

# Reducible combines elements
protocol Reducible[T]:
    def reduce[R](
        self,
        fn: Callable[[R, T], R],
        initial: R
    ) -> R:
        """Reduce to single value"""
        pass
```

Monoid types can be combined with each other. Lists combine by concatenation. Numbers combine by addition. Maps combine by merging. This protocol captures the idea of combination in a general way.

```python
from better_py.protocols import Monoid

# Monoid combines values
protocol Monoid[T]:
    def combine(self, other: T) -> T:
        """Combine two values"""
        pass

    @staticmethod
    def empty() -> T:
        """Return empty value"""
        pass
```

Combinable is a simpler version of Monoid that only requires the combine operation. Numbers, strings, and collections are all combinable.

```python
from better_py.protocols import Combinable

# Combinable combines values
protocol Combinable[T]:
    def combine(self, other: T) -> T:
        """Combine with another value"""
        pass
```

Updatable types support key-value updates like a dictionary. PersistentMap implements this protocol, and so do Python dictionaries.

```python
from better_py.protocols import Updatable

# Updatable modifies key-value pairs
protocol Updatable[K, V]:
    def set(self, key: K, value: V) -> Updatable[K, V]:
        """Set a key-value pair"""
        pass

    def delete(self, key: K) -> Updatable[K, V]:
        """Delete a key"""
        pass
```

Traversable types support a traverse operation that's like map but for functions that return monads. This is useful for validation and other scenarios where you're working with monadic operations over collections.

```python
from better_py.protocols import Traversable

# Traversable transforms with monadic functions
protocol Traversable[T]:
    def traverse[M](
        self,
        fn: Callable[[T], M]
    ) -> M:
        """Transform with monadic function"""
        pass
```

## Using Protocols in Your Code

Write functions that accept protocol-constrained types when you want them to work with multiple implementations. The type system ensures that any type passed actually satisfies the protocol, catching mismatches at compile time.

```python
from better_py.protocols import Monoid

def combine_all[T: Monoid](items: list[T]) -> T:
    """Combine all monoidal values"""
    if not items:
        return items[0].empty() if items else None

    result = items[0]
    for item in items[1:]:
        result = result.combine(item)
    return result

# Works with any Monoid
combine_all([PersistentList.of(1), PersistentList.of(2)])
# PersistentList(1, 2)

combine_all(["Hello", " ", "World"])
# "Hello World"
```

Type constraints ensure that types support required operations. When you constrain a type parameter with a protocol, the type system verifies that all the operations you perform are valid.

```python
from better_py.protocols import Mappable, Reducible

def process[T: (Mappable, Reducible)](data: T) -> float:
    """Transform and reduce"""
    return (
        data.map(lambda x: x * 2)
        .reduce(lambda acc, x: acc + x, 0)
    ) / len(data)
```

Protocol composition lets you combine multiple protocols to express complex requirements. A type must satisfy all the protocols in the composition.

```python
from better_py.protocols import Mappable, Monoid

def transform_and_combine[T: (Mappable, Monoid)](
    items: T,
    fn: Callable
) -> T:
    return items.map(fn).combine(items)
```

## Implementing Protocols

Implementing protocols in your own types is straightforward. Just provide the required methods, and your type automatically satisfies the protocol. You don't need to explicitly declare it.

For example, here's a simple container that's both mappable and reducible:

```python
from better_py.protocols import Mappable, Reducible
from typing import Callable, TypeVar

T = TypeVar('T')
U = TypeVar('U')

class Box(Mappable[T], Reducible[T]):
    def __init__(self, value: T):
        self.value = value

    def map[U](self, fn: Callable[[T], U]) -> Box[U]:
        return Box(fn(self.value))

    def reduce[R](
        self,
        fn: Callable[[R, T], R],
        initial: R
    ) -> R:
        return fn(initial, self.value)

# Usage
box = Box(5)
result = box.map(lambda x: x * 2)  # Box(10)
total = box.reduce(lambda acc, x: acc + x, 0)  # 5
```

Custom monoids are useful for domain-specific types that have a natural combination operation. For example, money that can only be combined if the currencies match:

```python
from better_py.protocols import Monoid
from dataclasses import dataclass

@dataclass(frozen=True)
class Money(Monoid):
    amount: int
    currency: str

    def combine(self, other: Money) -> Money:
        if self.currency != other.currency:
            raise ValueError("Currency mismatch")
        return Money(self.amount + other.amount, self.currency)

    @staticmethod
    def empty() -> Money:
        return Money(0, "USD")

# Usage
wallet = Money(100, "USD").combine(Money(50, "USD"))
# Money(150, "USD")
```

<Callout type="info" title="Protocols Enable Extensibility">

The beauty of protocols is that you can add new types without modifying existing code. Your custom type automatically works with any function that accepts its protocols. This is the open/closed principle in action: code is open for extension but closed for modification.

</Callout>

## Protocol Benefits

Protocols make your code extensible. You can add new types that work with existing functions without modifying those functions. The new type just needs to implement the required methods, and the type system verifies the compatibility.

Testability improves dramatically with protocols. You can create test doubles that implement the same protocols as your production types. The test doubles can be simpler and more predictable than the real dependencies.

```python
class FakeDatabase(Reducible):
    def reduce(self, fn, initial):
        return fn(initial, test_data)

# Test with fake DB
test_with_database(FakeDatabase())
```

Reusability increases because functions work with any type that satisfies the protocol. You don't have to write separate versions for each type. One function works with all compatible types.

```python
def sum_all[T: Reducible](items: T) -> int:
    return items.reduce(lambda acc, x: acc + x, 0)

# Works with lists, PersistentList, custom types...
sum_all([1, 2, 3])
sum_all(PersistentList.of(1, 2, 3))
```

## Practical Examples

Protocols shine in real-world scenarios. One example is parsing. You can define a Parseable protocol and implement it for any type that can be created from a string.

```python
from better_py.protocols import Parseable
from better_py import Result

protocol Parseable[T]:
    @staticmethod
    def parse(source: str) -> Result[T, str]:
        """Parse from string"""
        pass

class User(Parseable):
    @staticmethod
    def parse(source: str) -> Result[User, str]:
        try:
            data = json.loads(source)
            return Result.ok(User.from_dict(data))
        except Exception as e:
            return Result.error(str(e))
```

Validation is another great use case. Define a Validable protocol and implement it for types that need validation. This gives you a consistent validation interface across all your types.

```python
from better_py.protocols import Validable
from better_py import Validation

protocol Validable[T]:
    def validate(self) -> Validation[T, str]:
        """Validate the value"""
        pass

class Email(Validable):
    def __init__(self, address: str):
        self.address = address

    def validate(self) -> Validation[Email, str]:
        if "@" not in self.address:
            return Validation.invalid(["Invalid email format"])
        return Validation.valid(self)
```

## When to Use Protocols

Protocols excel at defining capabilities that multiple types share. If you find yourself writing the same function for multiple types, consider defining a protocol and making the function generic.

Protocols are also great for library APIs. Define protocols for the capabilities your library needs, and users can implement them with their own types. This makes your library flexible without sacrificing type safety.

<Callout type="success" title="Great Use Cases for Protocols">

Define protocols when multiple types need to share capabilities, when you want to write generic reusable functions, when building extensible library APIs, or when you need to mock types for testing.

</Callout>

<Callout type="warning" title="When Protocols Might Be Overkill">

For simple one-off types or internal implementation details, protocols might be unnecessary. Use protocols when the abstraction pays for itself in reusability and clarity.

</Callout>

## Protocols in Practice

Protocols transform how you think about interfaces. Instead of rigid hierarchies, you have flexible capabilities. Instead of explicit inheritance, you have structural compatibility. This makes code more adaptable and easier to evolve.

The type system ensures that protocols aren't just conventions. When you say a function accepts a Mappable type, the type checker verifies that any type you pass actually has a map method. You get duck typing with compile-time verification.

Ready to explore protocols in depth? The protocol documentation shows all available protocols and how to implement them effectively in your code.
