---
title: Functional Entities
description: OOP-first approach to functional programming
---

# Functional Entities

Better-py takes an object-oriented approach to functional programming. Instead of standalone functions that you pass data to, we use objects that encapsulate both data and the operations that work with that data. This might seem contrary to functional programming principles, but it actually makes functional code more natural in Python.

The key insight is that objects and functions aren't opposites. Objects are just a way to organize functions and the data they operate on. Better-py uses objects to deliver functional programming patterns in a way that feels idiomatic to Python developers.

## Objects Over Functions

Traditional functional programming uses standalone functions. You call map with a function and a list. You call filter with a predicate and a list. You call reduce with a function and a list. This works, but it requires nesting function calls and reading code inside out.

Better-py uses methods on objects. You create a PersistentList and call map on it. You call filter on the result. You call reduce on that. The code reads left to right, following the flow of data. Each operation returns a new object, so you can chain operations naturally.

```python
# Traditional functional style
map(lambda x: x * 2, filter(lambda y: y > 0, items))

# Object-oriented functional style
PersistentList(items).filter(lambda y: y > 0).map(lambda x: x * 2)
```

The difference isn't just syntactic. The object-oriented version makes it clear what operations apply to what data. You don't have to trace through nested function calls to see which operation happens first. The code tells a story: take these items, filter them, then map the results.

## Why This Approach Works

Object-oriented functional programming leverages Python's strengths. Python is an object-oriented language. Developers expect to call methods on objects. IDEs are optimized for showing available methods on objects. The object-oriented approach makes better-py feel like natural Python, not a foreign functional language.

Method chaining reads like English. Each step is a clear transformation. You can read the code and understand what it does without parsing nested function calls. This clarity matters for maintainability, especially as code grows more complex.

```python
result = (
    Maybe.some(5)
    .map(lambda x: x * 2)
    .filter(lambda x: x > 5)
    .bind(lambda x: Maybe.some(x + 1))
)
```

Type safety improves with methods. When you call a method on an object, the type system knows what type the object is and can track how the method transforms it. Maybe[int].map(str) returns Maybe[str], and the type system tracks this transformation automatically.

```python
# Type: Maybe[int]
maybe_int = Maybe.some(42)

# Type: Maybe[str] - tracked automatically
maybe_str = maybe_int.map(str)
```

Discoverability is dramatically better with methods. When you have an object, your IDE shows all available methods. You don't have to remember which standalone functions work with which types. The methods are right there in the autocomplete.

```python
maybe = Maybe.some(42)
maybe.  # IDE shows: map, bind, filter, unwrap, etc.
```

## Core Design Principles

All functional entities in better-py follow consistent design principles. These principles make the library coherent and predictable. Once you understand how one entity works, you understand how they all work.

Immutability is fundamental. All entities are immutable. Once created, they never change. Operations return new entities rather than modifying the existing one. This eliminates bugs related to unexpected mutations and makes code easier to reason about.

```python
@dataclass(frozen=True)
class Maybe[T]:
    # Cannot be modified after creation
    pass
```

Fluent interfaces enable chaining. Methods return new instances of the same or related types. This lets you chain operations together, building complex transformations from simple steps.

```python
result = (
    Maybe.some(5)
    .map(lambda x: x * 2)  # Returns new Maybe
    .filter(lambda x: x > 5)  # Returns new Maybe
    .bind(lambda x: Maybe.some(x + 1))  # Returns new Maybe
)
```

Generic types provide full type safety. All entities are parameterized by the types they contain. The type system tracks these type parameters through transformations, ensuring type safety throughout.

```python
class Maybe[T]:
    def map[U](self, fn: Callable[[T], U]) -> Maybe[U]:
        # Type checker tracks: int -> str -> bool
        pass

Maybe.some(42).map(str).map(bool)
```

Protocol-based design enables flexibility. Entities implement protocols that define their capabilities. This lets you write generic code that works with any type implementing the protocol, not just specific types.

```python
def process[T: Mappable](data: T) -> T:
    return data.map(lambda x: x * 2)

# Works with any Mappable type
process(Maybe.some(5))
process(PersistentList.of(1, 2, 3))
```

## The Maybe Entity

Maybe encapsulates optional values. Instead of using None and constantly checking for it, you wrap values in Maybe. The Maybe entity provides methods to transform, chain, and extract the value safely.

Creating Maybe values is straightforward. Use Maybe.some to wrap a value that exists. Use Maybe.nothing to represent absence. Use Maybe.from_value to convert an existing value that might be None.

```python
from better_py import Maybe

# Create
maybe = Maybe.some(42)
empty = Maybe.nothing()
from_none = Maybe.from_value(get_value())
```

Transforming values returns a new Maybe without affecting the original. Map applies a function to the value inside the Maybe. If the Maybe is Nothing, map returns Nothing unchanged.

```python
# Transform - returns new Maybe
doubled = maybe.map(lambda x: x * 2)
```

Chaining operations with bind handles nested Maybe structures. If your function returns a Maybe, use bind to flatten the result instead of map.

```python
# Chain - returns new Maybe
chained = maybe.bind(lambda x: Maybe.some(x * 2))
```

Extracting values is the final step. Unwrap returns the value or raises an exception if called on Nothing. Unwrap_or returns the value or a default. Unwrap_or_else returns the value or calls a function to compute a default.

```python
# Extract
value = maybe.unwrap()  # 42
default = empty.unwrap_or(0)  # 0
lazy = empty.unwrap_or_else(lambda: compute_default())
```

## The Result Entity

Result encapsulates operations that can succeed or fail. Instead of raising exceptions, functions return Result. This makes error handling explicit and forces you to handle both success and failure cases.

Creating Result values is similar to Maybe. Use Result.ok for success and Result.error for failure. The type system tracks both the success type and the error type independently.

```python
from better_py import Result

# Create
success = Result.ok(42)
failure = Result.error("Failed")
```

Transforming the success value preserves the error. Map applies a function to the success value, leaving the error unchanged. If the Result is an error, map returns the error unchanged.

```python
# Transform - preserves error
mapped = success.map(lambda x: x * 2)  # Result.ok(84)
```

Chaining operations short-circuits on error. Bind applies a function that returns a Result. If the current Result is an error, bind returns the error immediately without calling the function.

```python
# Chain - short-circuits on error
chained = success.bind(lambda x: Result.ok(x * 2))
```

Handling results explicitly is required. The type system forces you to handle both cases. Use is_ok and is_error to check the state, then unwrap or unwrap_error accordingly.

```python
# Handle
if result.is_ok():
    value = result.unwrap()
else:
    error = result.unwrap_error()
```

## The PersistentList Entity

PersistentList provides an immutable list with structural sharing. All operations return new lists without modifying the original. This gives you the safety of immutability with the performance of structural sharing.

Creating a PersistentList works like creating a regular list. Use PersistentList.of to create from elements. Use from_iter to create from an existing iterable. Use empty to start with an empty list.

```python
from better_py import PersistentList

# Create
lst = PersistentList.of(1, 2, 3)
```

Transforming returns a new list. Map applies a function to each element. Filter keeps only matching elements. Both operations return new PersistentList instances.

```python
# Transform - returns new list
mapped = lst.map(lambda x: x * 2)  # [2, 4, 6]
filtered = lst.filter(lambda x: x > 1)  # [2, 3]
```

Modifying returns a new list. Append adds to the end. Prepend adds to the beginning. Slice returns a sublist. All operations are efficient thanks to structural sharing.

```python
# Modify - returns new list
appended = lst.append(4)  # [1, 2, 3, 4]
prepended = lst.prepend(0)  # [0, 1, 2, 3]
```

Reducing combines elements into a single value. Reduce takes a function and an initial value, applying the function to accumulate a result.

```python
# Reduce
total = lst.reduce(lambda acc, x: acc + x, 0)  # 6
```

## Method Chaining in Practice

Method chaining is the primary way to work with functional entities. Each operation returns a new entity, so you can chain operations together to express complex transformations concisely.

Compare nested function calls with method chaining. The nested version reads inside out. You have to find the innermost function and work your way out. The chained version reads left to right. Each step is clear and self-contained.

```python
# Nested - hard to read
result = map(
    lambda x: x * 2,
    filter(
        lambda y: y > 0,
        items
    )
)

# Chained - clear flow
result = (
    PersistentList(items)
    .filter(lambda y: y > 0)
    .map(lambda x: x * 2)
)
```

Real-world code shows the difference dramatically. Here's a user processing pipeline that fetches, enriches, and validates a user:

```python
from better_py import Maybe, Result

def process_user(id: int) -> Result[ValidatedUser, str]:
    return (
        fetch_user(id)  # Result[User, str]
        .map(lambda u: enrich_user(u))  # Result[EnrichedUser, str]
        .bind(lambda eu: validate_user(eu))  # Result[ValidatedUser, str]
    )

def get_user_email(id: int) -> Maybe[str]:
    return (
        Maybe.from_value(find_user(id))
        .map(lambda u: u.profile)
        .bind(lambda p: Maybe.from_value(p.email))
        .filter(lambda e: is_valid_email(e))
    )
```

The code reads like a description of what it does. Process user: fetch user, enrich user, validate user. Get user email: find user, get profile, get email, validate email. Each step is clear and testable.

## Self-Documenting Code

Methods make intent clear. When you read maybe.map, you know you're transforming the value inside. When you read maybe.bind, you know you're chaining operations that return Maybe. When you read maybe.filter, you know you're conditionally keeping the value.

Compare this to standalone functions where you have to remember which function works with which type. map_maybe, bind_maybe, filter_maybe - the names are longer and less clear.

```python
# Clear intent with methods
maybe.map(lambda x: x * 2)
maybe.bind(lambda x: Maybe.some(x + 1))
maybe.filter(lambda x: x > 0)

# Unclear intent with functions
map_maybe(maybe, lambda x: x * 2)
bind_maybe(maybe, lambda x: Maybe.some(x + 1))
filter_maybe(maybe, lambda x: x > 0)
```

## Encapsulation of Logic

Functional entities encapsulate related operations. All Maybe logic is in the Maybe class. All Result logic is in the Result class. This organization makes code easier to understand and maintain.

When you need to understand how Maybe works, you look in one place. When you need to add a new operation, you add it to the entity. Everything related to that entity is together.

```python
class Maybe:
    # All Maybe logic in one place
    def map(self, fn):
        # Transform logic
        pass

    def bind(self, fn):
        # Chain logic
        pass

    def filter(self, pred):
        # Filter logic
        pass
```

## When to Use Each Approach

Better-py's entity-first approach excels in application code, business logic, data pipelines, team projects, and large codebases. These are situations where clarity, maintainability, and discoverability matter.

```python
# Entity-first for application code
result = (
    fetch_user(id)
    .map(enrich)
    .bind(validate)
)
```

Traditional function-first FP can be appropriate for simple scripts, library code, performance-critical code, or interfacing with functional APIs. These are situations where conciseness or performance matters more than discoverability.

```python
# Function-first for simple operations
def transform(x):
    return x * 2
```

You can mix both styles in the same codebase. Use entities for complex logic and functions for simple operations. The key is to choose the approach that makes the code clearest.

<Callout type="success" title="Use Entity-First Approach For">

Application code, business logic, data pipelines, team projects, and large codebases benefit from the discoverability and clarity of method chaining.

</Callout>

<Callout type="info" title="Use Function-First Approach For">

Simple scripts, library code, performance-critical code, or interfacing with functional APIs might be more natural with standalone functions.

</Callout>

## Making the Transition

If you're coming from traditional functional programming, the entity-first approach might feel unfamiliar at first. But give it a try. You might find that method chaining feels more natural than nested function calls, especially in Python.

Start by using entities for new code. You don't have to refactor existing code immediately. As you become comfortable with the approach, you'll naturally find places where it improves clarity and maintainability.

The entity-first approach isn't about abandoning functional programming principles. It's about expressing those principles in a way that feels natural in Python. Immutability, pure functions, composition - they're all there. Just packaged in objects that fit Python's object-oriented nature.

Ready to dive deeper? The detailed documentation shows how each entity works and provides examples of real-world usage patterns.
