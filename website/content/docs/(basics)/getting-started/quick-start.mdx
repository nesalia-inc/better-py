---
title: Quick Start
description: Build your first functional program in 5 minutes
---

import { Steps, Step } from 'fumadocs-ui/components/steps';

The best way to learn better-py is to build something real. In this guide, we'll create a user lookup service that demonstrates the core concepts of functional programming: optional values, error handling, and data validation.

---

## What We're Building

We'll build a simple user service with three layers of safety:

1. **Safe lookups** with `Maybe` - handle missing users without crashes
2. **Explicit errors** with `Result` - validate input and show clear error messages
3. **Data validation** with `Validation` - accumulate multiple errors at once

This isn't just academic. These patterns appear constantly in real applications: database queries, API calls, form processing, and configuration parsing. By the end, you'll have patterns you can apply immediately.

---

## Setting Up the Project

First, create a new directory and set up a Python environment:

```bash
mkdir user-service
cd user-service
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install better-py-fp
```

This creates a clean workspace with better-py installed. The virtual environment keeps dependencies isolated, which is always a good practice.

---

## Understanding Maybe: Handling Missing Values

Before we write code, let's understand the problem we're solving. In traditional Python code, when you look up something that might not exist, you have to remember to check for `None`:

```python
# Traditional approach - error-prone
user = find_user(1)
if user is not None:
    email = user.get("email")
    if email is not None:
        print(email)
```

This works but it's tedious. It's easy to forget a check, leading to crashes. Maybe solves this by making the possibility of absence explicit in the type system.

Think of Maybe as a container that either holds a value or holds nothing. Every operation you perform acknowledges this uncertainty, so you can't accidentally access a missing value.

Let's start building our user service with Maybe:

```python
from better_py import Maybe

# Simulated database
users_db = {
    1: {"id": 1, "name": "Alice", "email": "alice@example.com"},
    2: {"id": 2, "name": "Bob", "email": "bob@example.com"},
}

def find_user(user_id: int) -> Maybe[dict]:
    """Find a user by ID - returns Maybe[dict]"""
    if user_id in users_db:
        return Maybe.some(users_db[user_id])
    return Maybe.nothing()

# Test it
result = find_user(1)
if result.is_some():
    user = result.unwrap()
    print(f"Found user: {user['name']}")
else:
    print("User not found")
```

The return type `Maybe[dict]` tells anyone reading this code that the user might not exist. You don't need to read the implementation to know you should handle both cases. Compare this to a function that returns `dict | None` - you have to guess whether `None` is actually possible or just a theoretical possibility.

<Callout type="info" title="Why not just use None?">

The problem with `None` is that it's implicit. You can return `None` from any function, but Python won't force callers to handle it. Maybe makes absence explicit and requires you to acknowledge it.

</Callout>

---

## Transforming Maybe Values

Looking up a user is just the beginning. Often you want to extract or transform data from the user. Maybe provides operations that let you work with the value inside while maintaining safety.

Let's say we want to get a user's email address. The challenge is that the user might not exist, and even if they do, they might not have an email set. We need to handle both cases:

```python
from better_py import Maybe

def get_user_email(user_id: int) -> Maybe[str]:
    """Get user email or Nothing if not found"""
    return (
        find_user(user_id)                    # Maybe[dict]
        .map(lambda user: user.get("email"))  # Maybe[str | None]
        .bind(lambda email:                   # Maybe[str]
            Maybe.some(email) if email
            else Maybe.nothing()
        )
    )

# Test with existing user
email = get_user_email(1)
print(email.unwrap_or_else(lambda: "No email"))
# Output: alice@example.com

# Test with non-existent user
email = get_user_email(999)
print(email.unwrap_or_else(lambda: "No email"))
# Output: No email
```

This code demonstrates two key operations: `map` and `bind`. Use `map` when your transformation returns a regular value, and `bind` when your transformation returns another Maybe. The distinction matters because `bind` flattens nested Maybe structures, keeping your code clean.

The beauty of this approach is that it reads like a series of steps: "find the user, get their email, ensure it exists." If any step fails (returns Nothing), the entire chain safely returns Nothing without throwing an error.

---

## Handling Errors with Result

Maybe handles the case where something doesn't exist, but sometimes you need to explain why something failed. This is where Result comes in.

Result represents either success (with a value) or failure (with an error). Unlike exceptions, which can be thrown from anywhere, Result forces you to handle errors explicitly at the call site.

Let's add input validation to our user service:

```python
from better_py import Result

def validate_user_id(user_id: int) -> Result[int, str]:
    """Validate user ID - returns Result[int, str]"""
    if user_id <= 0:
        return Result.error("User ID must be positive")
    if user_id > 1000:
        return Result.error("User ID too large")
    return Result.ok(user_id)

# Test validation
result = validate_user_id(-1)
if result.is_ok():
    user_id = result.unwrap()
    print(f"Valid ID: {user_id}")
else:
    print(f"Error: {result.unwrap_error()}")
# Output: Error: User ID must be positive
```

The type `Result[int, str]` tells you that on success you get an integer, and on failure you get a string error message. Unlike exceptions, which hide their failure modes, Result makes error handling part of the function signature.

This is particularly valuable in larger systems. When you see a function returns `Result[User, str]`, you immediately know you need to handle both success and failure cases. You don't need to read the function body or catch obscure exceptions.

---

## Combining Maybe and Result

Real applications need both types of safety: input validation (Result) and data lookups (Maybe). The key is knowing when to use each:

- Use **Result** when you have meaningful error information (validation failures, parse errors, I/O errors)
- Use **Maybe** when absence is a normal possibility (cache misses, optional fields, lookups)

Let's combine them in our user service:

```python
from better_py import Maybe, Result

def get_user_safe(user_id: int) -> Result[dict, str]:
    """Get user with validation and safe lookup"""
    # First validate the ID
    validated = validate_user_id(user_id)
    if validated.is_error():
        return validated

    # Then find the user
    user = find_user(validated.unwrap())
    if user.is_nothing():
        return Result.error(f"User {user_id} not found")

    return Result.ok(user.unwrap())

# Test the complete flow
result = get_user_safe(1)
if result.is_ok():
    print(f"Success: {result.unwrap()}")
else:
    print(f"Error: {result.unwrap_error()}")
# Output: Success: {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'}

result = get_user_safe(-1)
if result.is_ok():
    print(f"Success: {result.unwrap()}")
else:
    print(f"Error: {result.unwrap_error()}")
# Output: Error: User ID must be positive
```

Notice how each layer adds safety: validation prevents invalid input, Maybe handles missing users, and Result propagates meaningful errors. If you called this function, you'd know exactly what could go wrong and how to handle each case.

---

## Accumulating Errors with Validation

Sometimes you want to show all errors at once rather than failing on the first one. This is especially useful in form validation, where users prefer to see all issues at once instead of fixing them one at a time.

Validation accumulates errors while still maintaining type safety:

```python
from better_py import Validation

def validate_email(email: str) -> Validation[str, str]:
    """Validate email format"""
    if "@" in email and "." in email:
        return Validation.valid(email)
    return Validation.invalid(["Invalid email format"])

def validate_name(name: str) -> Validation[str, str]:
    """Validate name length"""
    if len(name) >= 2:
        return Validation.valid(name)
    return Validation.invalid(["Name must be at least 2 characters"])

def validate_user_data(name: str, email: str) -> Validation[dict, str]:
    """Validate all user data and accumulate errors"""
    name_result = validate_name(name)
    email_result = validate_email(email)

    # Combine validations - accumulates all errors
    return name_result.ap(email_result).map(
        lambda data: {"name": data[0], "email": data[1]}
    )

# Test validation with multiple errors
result = validate_user_data("A", "bademail")
if result.is_valid():
    print(f"Valid: {result.unwrap()}")
else:
    print(f"Errors: {result.get_errors()}")
# Output: Errors: ['Name must be at least 2 characters', 'Invalid email format']

# Test with valid data
result = validate_user_data("Alice", "alice@example.com")
if result.is_valid():
    print(f"Valid: {result.unwrap()}")
else:
    print(f"Errors: {result.get_errors()}")
# Output: Valid: {'name': 'Alice', 'email': 'alice@example.com'}
```

The power here is that both validations run regardless of whether the first one fails. The `ap` (apply) operation combines them, collecting all errors together. This gives users a better experience by showing everything they need to fix.

---

## Putting It All Together

Now let's assemble our complete user service. This demonstrates how these concepts work together in a real application:

```python
from better_py import Maybe, Result, Validation

# Database
users_db = {
    1: {"id": 1, "name": "Alice", "email": "alice@example.com"},
    2: {"id": 2, "name": "Bob", "email": "bob@example.com"},
}

# Core functions
def find_user(user_id: int) -> Maybe[dict]:
    """Find user by ID"""
    return Maybe.some(users_db[user_id]) if user_id in users_db else Maybe.nothing()

def validate_user_id(user_id: int) -> Result[int, str]:
    """Validate user ID"""
    if user_id <= 0:
        return Result.error("User ID must be positive")
    if user_id > 1000:
        return Result.error("User ID too large")
    return Result.ok(user_id)

# Main function
def get_user_info(user_id: int) -> Result[dict, str]:
    """Get user info with full validation"""
    # Validate ID
    validated_id = validate_user_id(user_id)
    if validated_id.is_error():
        return validated_id.map_error(lambda e: f"Validation error: {e}")

    # Find user
    user = find_user(validated_id.unwrap())
    if user.is_nothing():
        return Result.error(f"User {user_id} not found")

    return Result.ok(user.unwrap())

# CLI interface
def main():
    import sys

    if len(sys.argv) < 2:
        print("Usage: python main.py <user_id>")
        return

    try:
        user_id = int(sys.argv[1])
    except ValueError:
        print("Error: User ID must be a number")
        return

    result = get_user_info(user_id)

    if result.is_ok():
        user = result.unwrap()
        print(f"Found user:")
        print(f"  Name: {user['name']}")
        print(f"  Email: {user['email']}")
    else:
        print(f"{result.unwrap_error()}")

if __name__ == "__main__":
    main()
```

Save this as `main.py` and test it with different inputs:

```bash
python main.py 1
# Found user:
#   Name: Alice
#   Email: alice@example.com

python main.py 999
# User 999 not found

python main.py -1
# Validation error: User ID must be positive
```

Every error is handled explicitly. No unexpected crashes, no confusing stack traces for users, and complete type safety throughout.

---

## Key Concepts to Remember

You've just learned the three core abstractions that better-py provides:

**Maybe** handles optional values. Use it when something might not exist, and you don't need to explain why. Database lookups, cache hits, and dictionary access with default values are good candidates.

**Result** handles operations that can fail with meaningful errors. Use it when you need to communicate what went wrong. File parsing, network requests, and validation all benefit from Result.

**Validation** accumulates multiple errors. Use it when you want to show all problems at once, like form validation or batch processing.

The pattern across all three is the same: make error cases explicit in the type system, force callers to handle them, and provide clean operations for composing them together.

<Callout type="success" title="You're ready to build!">

You now understand the core concepts of better-py. The mental model you've developed here applies to many real-world scenarios. Continue your journey by diving deeper into each concept:

- [Maybe Monad](/docs/monads/maybe) - Learn advanced patterns for optional values
- [Result Monad](/docs/monads/result) - Master error handling strategies
- [Validation Monad](/docs/monads/validation) - Explore form validation patterns
- [Real-world Examples](/docs/examples) - See better-py in production code

</Callout>
