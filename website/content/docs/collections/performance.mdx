---
title: Performance
description: Performance characteristics of persistent collections
---

# Performance

Understanding the performance characteristics of persistent collections.

---

## Structural Sharing

Persistent collections use **structural sharing** - unchanged parts are shared between versions.

```python
from better_py import PersistentList

list1 = PersistentList.of(1, 2, 3)  # Creates 3 nodes
list2 = list1.prepend(0)           # Creates 1 new node, shares [1,2,3]

# Only 4 nodes total, not 6
```

<Callout type="success" title="Benefits">

-  Memory efficient
-  Fast "copying"
-  Immutable = thread-safe

</Callout>

---

## Time Complexity

### PersistentList

| Operation | Complexity | Notes |
|-----------|------------|-------|
| prepend() | O(1) | Most efficient |
| append() | O(n) | Creates new list |
| head() | O(1) | First element |
| tail() | O(1) | Rest of list |
| get(index) | O(n) | Linear search |
| map() | O(n) | Full traversal |
| filter() | O(n) | Full traversal |

### PersistentMap

| Operation | Complexity | Notes |
|-----------|------------|-------|
| get() | O(log n) | Tree-based |
| set() | O(log n) | Returns new map |
| delete() | O(log n) | Returns new map |
| set_in() | O(log n Ã— depth) | Deep update |

### PersistentSet

| Operation | Complexity | Notes |
|-----------|------------|-------|
| add() | O(log n) | Tree-based |
| remove() | O(log n) | Returns new set |
| contains() | O(log n) | Membership test |
| union() | O(n + m) | Two sets |
| intersection() | O(min(n,m)) | Common elements |

---

## Memory Usage

Structural sharing keeps memory usage low:

```python
from better_py import PersistentList

# Each version shares nodes
v1 = PersistentList.of(1, 2, 3)   # ~3 nodes
v2 = v1.prepend(0)                 # ~1 new node (shares 3)
v3 = v2.prepend(-1)                # ~1 new node (shares 4)

# Total: ~5 nodes, not 9
```

---

## When to Use Persistent Collections

<Callout type="success" title="Use When">

-  Need immutability
-  Frequent prepend operations
-  Keeping history/versions
-  Concurrent access
-  Functional programming

</Callout>

<Callout type="warning" title="Consider Alternatives When">

-  Need random access (use built-in list)
-  Frequent append operations
-  Large data volumes
-  Performance-critical inner loops

</Callout>

---

## Benchmarks

### Prepend Performance

```python
from better_py import PersistentList

lst = PersistentList.empty()
for i in range(10000):
    lst = lst.prepend(i)  # O(1) per operation
# Fast!
```

### Append Performance

```python
from better_py import PersistentList

lst = PersistentList.empty()
for i in range(1000):
    lst = lst.append(i)  # O(n) per operation
# Slower - consider reverse + prepend pattern
```

---

## Optimization Tips

### Pattern 1: Build in Reverse, Then Reverse

```python
# Slow: Many appends
lst = PersistentList.empty()
for i in range(1000):
    lst = lst.append(i)  # O(n) each

# Fast: Prepend then reverse
lst = PersistentList.empty()
for i in reversed(range(1000)):
    lst = lst.prepend(i)  # O(1) each
lst = lst.reverse()  # O(n) once
```

### Pattern 2: Convert to List for Bulk Operations

```python
from better_py import PersistentList

# Build in bulk
regular_list = [i for i in range(1000)]
persistent = PersistentList.from_iterable(regular_list)
```

---

## See Also

- [Immutability](/docs/concepts/immutability) - Learn about immutability benefits
- [Best Practices](/docs/best-practices/performance) - Performance optimization
