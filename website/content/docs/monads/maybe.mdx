---
title: Maybe Monad
description: Handle optional values safely without None checks
---

import { CheckCircle, XCircle, AlertTriangle } from 'lucide-react';

# Maybe Monad

The `Maybe` monad represents optional values - situations where a value might exist or might not. It's a type-safe alternative to using `None` in Python, helping you avoid the common pitfalls of null reference errors.

---

## Understanding Maybe: The Box Analogy

To understand Maybe, imagine you're holding a box. This box might contain something valuable inside, or it might be empty. The key is that you can't tell just by looking at the outside - you need to check what's inside before you can use the contents.

In regular Python, values work like holding an object directly in your hand. You might be holding something valuable, or you might be holding `None` (which is like holding nothing at all). The problem is that you won't know until you try to use it, and if you forget to check, you might crash your program.

Maybe puts the value inside a protective box. This box has two possible states:

- **Some**: The box contains a value
- **Nothing**: The box is empty

Every operation with Maybe acknowledges this uncertainty. You can't directly access what's inside the box without checking first. The type system knows the value is optional, and in typed Python, your code won't even compile if you forget to handle the empty case.

This is different from a simple `None` check because the possibility of emptiness is encoded in the type itself. When you see a function return `Maybe[User]`, you know immediately that you might not get a user back. You don't have to read the documentation or guess - it's right there in the type signature.

<Callout type="success" title="When to Use Maybe">

Think of Maybe whenever you encounter these situations:

- **Database queries** that might not find a matching record
- **Dictionary lookups** where the key might not exist
- **Configuration values** that have defaults
- **Optional fields** on data structures (like a user profile without a phone number)
- **Search operations** where nothing matches the criteria

Use Maybe when the absence of a value is normal and expected. When you need to know WHY something is missing, use Result instead.

</Callout>

---

## Why Maybe Matters

Python's approach to optional values is simple but error-prone. You can return `None` to indicate absence, but it's easy to forget to check for it. This leads to crashes with `AttributeError: 'NoneType' object has no attribute 'something'`.

Maybe solves this by making absence explicit. Consider a common scenario - safely accessing nested dictionary values:

```python
# Without Maybe - fragile
def get_user_city(user: dict) -> str | None:
    if user is None:
        return None
    profile = user.get("profile")
    if profile is None:
        return None
    address = profile.get("address")
    if address is None:
        return None
    return address.get("city")

# With Maybe - clean and safe
def get_user_city(user: dict) -> Maybe[str]:
    return (
        Maybe.from_value(user)
        .map(lambda u: u.get("profile"))
        .map(lambda p: p.get("address") if p else None)
        .map(lambda a: a.get("city") if a else None)
    )
```

The Maybe version chains operations cleanly, and if any step returns `Nothing`, the entire chain short-circuits. No nested conditionals, no repeated `None` checks, and the type signature makes it clear that the function might not return a city.

---

## Creating Maybe Values

Maybe provides several ways to create values, depending on what you're working with.

### Creating a Value That Exists

When you know you have a value and want to wrap it in a Maybe, use `Maybe.some()`:

```python
from better_py import Maybe

user = Maybe.some({"id": 1, "name": "Alice"})
age = Maybe.some(30)
```

This creates a `Some` variant containing your value. You're explicitly saying "this value exists."

### Representing Absence

When you want to represent the absence of a value, use `Maybe.nothing()`:

```python
empty = Maybe.nothing()
```

This creates a `Nothing` variant. It's not wrapping `None` - it's representing the concept of absence itself.

### Converting Existing Values

In practice, you often have values that might already be `None`. Use `Maybe.from_value()` to convert them:

```python
# With an actual value
Maybe.from_value(42)         # Returns: Maybe(42)

# With None
Maybe.from_value(None)       # Returns: Nothing

# With a value that might be None
def find_user(id: int) -> dict | None:
    return database.query(id)

maybe_user = Maybe.from_value(find_user(123))
# If user exists: Maybe(user_dict)
# If user is None: Nothing
```

The `from_value()` method checks if the value is `None` and automatically creates `Nothing`. Otherwise, it wraps the value in `Some`.

### Distinguishing None from Nothing

better-py includes a special feature that lets you distinguish between wrapping `None` as a value and representing absence. Use `Maybe.some_none()` to explicitly wrap `None`:

```python
# Explicitly wrap None as a value
some_none = Maybe.some_none()     # Creates: Some(None)
nothing = Maybe.nothing()         # Creates: Nothing

# They behave differently
some_none.is_some()               # Returns: True
nothing.is_some()                 # Returns: False

# Unwrap returns different things
some_none.unwrap()                # Returns: None
nothing.unwrap()                  # Raises: ValueError (because it's empty)
```

This is useful in rare cases where `None` itself is a meaningful value that you need to distinguish from absence. For example, a search function might return `None` to mean "found but has no value" versus `Nothing` to mean "not found."

<Callout type="warning" title="Breaking Change">

In better-py, `Maybe.some(None)` now returns `Some(None)`, not `Nothing`. This is different from some other libraries. Use `Maybe.from_value(None)` if you want `Nothing`.

</Callout>

---

## Inspecting Maybe Values

Before you can do anything useful with a Maybe value, you need to check whether it contains something or is empty. Maybe provides two methods for this.

### Checking If a Value Exists

The `is_some()` method returns `True` if the Maybe contains a value:

```python
Maybe.some(42).is_some()      # Returns: True
Maybe.nothing().is_some()     # Returns: False
```

Use this when you want to verify that a value exists before proceeding.

### Checking If a Value Is Absent

The `is_nothing()` method returns `True` if the Maybe is empty:

```python
Maybe.some(42).is_nothing()    # Returns: False
Maybe.nothing().is_nothing()   # Returns: True
```

These two methods are opposites - exactly one will return `True` for any Maybe value.

---

## Transforming Maybe Values

The real power of Maybe comes from transforming values while keeping them safely wrapped. You don't need to unwrap and rewrap - Maybe handles it for you.

### Applying Functions to Wrapped Values

When you have a Maybe value and want to transform its contents, use `map()`. This applies a function to the value inside the Maybe wrapper, preserving the optional nature of the result.

```python
Maybe.some(5).map(lambda x: x * 2)      # Returns: Maybe(10)
Maybe.nothing().map(lambda x: x * 2)    # Returns: Nothing
```

If the Maybe is `Nothing`, the transformation is skipped and `Nothing` is returned. The function never runs.

In a real application, you might use this to extract fields from an optional user:

```python
def get_user_email(user_id: int) -> Maybe[str]:
    return (
        find_user(user_id)
        .map(lambda user: user.email)
        .filter(lambda email: "@" in email)
    )
```

This reads like English: "find the user, get their email, keep it only if it contains @" If any step fails, you get `Nothing` back.

### Filtering Values

Sometimes you want to keep a value only if it meets certain criteria. Use `filter()` for this:

```python
Maybe.some(5).filter(lambda x: x > 10)     # Returns: Nothing (5 is not > 10)
Maybe.some(15).filter(lambda x: x > 10)    # Returns: Maybe(15)
Maybe.nothing().filter(lambda x: x > 10)   # Returns: Nothing
```

If the predicate returns `False`, the value becomes `Nothing`. This is useful for validation:

```python
def get_adult_user(user_id: int) -> Maybe[User]:
    return (
        find_user(user_id)
        .filter(lambda user: user.age >= 18)
    )
```

---

## Chaining Optional Operations

One of the most common patterns with Maybe is chaining multiple operations that each might return `Nothing`. For example, looking up a user might return `Maybe[User]`, and then fetching their profile might return `Maybe[Profile]`.

If you use `map()` for this, you end up with nested Maybes: `Maybe[Maybe[Profile]]`. This is awkward to work with. Instead, use `bind()` (also called `and_then()` or `flat_map()`) to flatten the result.

### Chaining with bind()

The `bind()` method takes a function that returns a Maybe and flattens the result:

```python
def find_user(id: int) -> Maybe[User]:
    return Maybe.from_value(database.query(id))

def get_profile(user: User) -> Maybe[Profile]:
    return Maybe.from_value(user.profile)

def get_avatar(profile: Profile) -> Maybe[str]:
    return Maybe.from_value(profile.avatar_url)

# Chain them together
avatar_url = (
    find_user(123)
    .bind(get_profile)
    .bind(get_avatar)
)
# Returns: Maybe[str] - not Maybe[Maybe[Maybe[str]]]
```

If `find_user` returns `Nothing`, the chain stops immediately. `get_profile` and `get_avatar` never run. This is called "short-circuiting" and it's exactly what you want - you don't try to fetch a profile for a user that doesn't exist.

This pattern is incredibly common in real applications. Any time you have a series of operations where each might fail, `bind()` keeps your code clean and readable.

---

## Combining Maybe Values

Sometimes you need to work with multiple Maybe values at once. Maybe provides utilities for this.

### Providing Alternative Values

The `or_else()` method lets you provide an alternative Maybe if the first one is `Nothing`:

```python
def get_config(key: str) -> Maybe[str]:
    return (
        Maybe.from_value(os.getenv(key))
        .or_else(Maybe.from_value(DEFAULTS.get(key)))
    )
```

This tries to get the value from the environment first, and falls back to the defaults if that's `Nothing`. You can chain multiple `or_else()` calls to try several sources in order.

### Combining Multiple Maybes

The `zip()` method combines multiple Maybe values into one. All values must exist for the combination to succeed:

```python
name = Maybe.some("Alice")
age = Maybe.some(30)
email = Maybe.nothing()

result = Maybe.zip(name, age, email)
# Returns: Nothing (because email is Nothing)
```

This is useful when you need all pieces of data to proceed:

```python
def send_notification(user_id: int) -> Result[None, str]:
    # Need all contact methods
    return (
        Maybe.zip(
            get_email(user_id),
            get_phone(user_id),
            get_push_token(user_id)
        )
        .to_result("Missing contact info")
        .map(lambda contact: send_to_all(contact))
    )
```

---

## Extracting Values from Maybe

Eventually, you need to get the value out of the Maybe wrapper. Maybe provides several ways to do this, ranging from unsafe (can crash) to safe (always succeeds).

### Unsafe Extraction

The `unwrap()` method returns the value inside, but raises an exception if called on `Nothing`:

```python
Maybe.some(42).unwrap()      # Returns: 42
Maybe.nothing().unwrap()     # Raises: ValueError
```

Only use `unwrap()` when you've already verified that the value exists, or in tests where you want failures to be explicit. Never use it in library code - it forces your users to handle exceptions, which defeats the purpose of Maybe.

### Safe Extraction with a Default

The `unwrap_or()` method returns the value if it exists, or a default value if it doesn't:

```python
Maybe.some(42).unwrap_or(0)       # Returns: 42
Maybe.nothing().unwrap_or(0)      # Returns: 0
```

This is the most common way to extract values. Use it when you have a sensible default:

```python
theme = get_user_theme(user_id).unwrap_or("light")
timeout = get_timeout(config).unwrap_or(30)
```

### Lazy Default Computation

Sometimes computing the default value is expensive (like querying a database or making an API call). Use `unwrap_or_else()` to compute the default only if needed:

```python
Maybe.some(42).unwrap_or_else(lambda: expensive_computation())    # Returns: 42 (doesn't compute)
Maybe.nothing().unwrap_or_else(lambda: expensive_computation())   # Returns: result of expensive_computation()
```

The function only runs if the Maybe is `Nothing`, saving you from unnecessary work.

### Pattern Matching with fold()

The `fold()` method (also called `match()` or `cata()`) lets you handle both cases in one place:

```python
def format_maybe(maybe: Maybe[int]) -> str:
    return maybe.fold(
        on_nothing=lambda: "No value",
        on_some=lambda x: f"Value: {x}"
    )

format_maybe(Maybe.some(42))     # Returns: "Value: 42"
format_maybe(Maybe.nothing())     # Returns: "No value"
```

This is useful when you need to transform both cases into a common type, like formatting a Maybe for display.

---

## Real-World Examples

### Safe Dictionary Navigation

Navigating nested dictionaries safely is one of Maybe's most common uses. Instead of nested `if` statements, you can chain operations:

```python
from better_py import Maybe

config = {
    "database": {
        "host": "localhost",
        "port": 5432
    }
}

def get_nested_config(config: dict, *keys: str) -> Maybe:
    """Safely navigate nested dictionary keys"""
    result = Maybe.some(config)
    for key in keys:
        result = result.bind(lambda d:
            Maybe.from_value(d.get(key) if isinstance(d, dict) else None)
        )
    return result

host = get_nested_config(config, "database", "host")
port = get_nested_config(config, "database", "port")
missing = get_nested_config(config, "database", "user")

host.unwrap_or("localhost")    # Returns: "localhost"
port.unwrap_or(5432)           # Returns: 5432
missing.unwrap_or("default")   # Returns: "default"
```

### Chaining Database Operations

When working with a database, operations often depend on each other. If a user doesn't exist, they can't have a profile. If they don't have a profile, they can't have an avatar. Maybe makes this dependency chain clean:

```python
def find_user(user_id: int) -> Maybe[User]:
    return Maybe.from_value(db.query(User).filter_by(id=user_id).first())

def get_profile(user: User) -> Maybe[Profile]:
    return Maybe.from_value(db.query(Profile).filter_by(user_id=user.id).first())

def get_avatar_url(profile: Profile) -> Maybe[str]:
    return Maybe.from_value(profile.avatar_url if profile.avatar_enabled else None)

# Chain them all together
def get_user_avatar(user_id: int) -> Maybe[str]:
    return (
        find_user(user_id)
        .bind(get_profile)
        .bind(get_avatar_url)
    )

# Use it
avatar_url = get_user_avatar(user_id).unwrap_or("/default_avatar.png")
```

If any step fails, the entire chain returns `Nothing` and the default avatar is used. No crashes, no nested conditionals.

### Configuration with Fallbacks

Configuration often comes from multiple sources with a priority order. Maybe's `or_else()` makes this pattern explicit:

```python
import os
from better_py import Maybe

DEFAULT_CONFIG = {
    "host": "localhost",
    "port": 8080,
    "debug": False
}

def get_config_value(key: str) -> Maybe:
    """Try environment variables, then defaults, then Vault"""
    env_value = Maybe.from_value(os.getenv(key.upper()))
    default_value = Maybe.from_value(DEFAULT_CONFIG.get(key))
    vault_value = Maybe.from_value(read_from_vault(key))

    return env_value.or_else(default_value).or_else(vault_value)

# Usage
host = get_config_value("host").unwrap_or("localhost")
port = get_config_value("port").map(int).unwrap_or(8080)
debug = get_config_value("debug").map(lambda v: v == "true").unwrap_or(False)
```

Each source is tried in order, falling back to the next if the previous is `Nothing`.

---

## Common Mistakes

### Mistake 1: Unwrapping Too Early

A common mistake is to unwrap a Maybe value as soon as you get it, losing all the safety benefits:

```python
# DON'T - loses Maybe's benefits
def get_user_name(user_id: int) -> str:
    user = find_user(user_id).unwrap()  # Crashes if user not found!
    return user.name

# DO - keep it wrapped
def get_user_name(user_id: int) -> Maybe[str]:
    return find_user(user_id).map(lambda user: user.name)
```

Keep values wrapped until you absolutely need them. Let the Maybe type safety work for you.

### Mistake 2: Ignoring the Nothing Case

When you extract values, make sure you're handling the `Nothing` case appropriately:

```python
# DON'T - always processes, even when value is the default
maybe_value = get_config(key)
value = maybe_value.unwrap_or(default)
process(value)  # Processes the default even when config was missing

# DO - only process when value exists
maybe_value = get_config(key)
if maybe_value.is_some():
    process(maybe_value.unwrap())
```

The default value should mean "this is fine to use," not "I should use this instead of handling the missing case."

### Mistake 3: Using Maybe for Errors

Maybe is for optional values, not for error handling. When you need to know WHY something failed, use Result:

```python
# DON'T - can't distinguish between different error cases
def fetch_user(id: int) -> Maybe[User]:
    try:
        return Maybe.some(api.get_user(id))
    except NetworkError:
        return Maybe.nothing()  # Was it network? Not found? Timeout?
    except AuthError:
        return Maybe.nothing()  # Same result, different error

# DO - use Result for error information
def fetch_user(id: int) -> Result[User, Error]:
    try:
        return Result.ok(api.get_user(id))
    except NetworkError as e:
        return Result.error(Error.Network(str(e)))
    except AuthError as e:
        return Result.error(Error.Auth(str(e)))
```

---

## When NOT to Use Maybe

Maybe is a powerful tool, but it's not always the right choice.

### Simple if/else Is Clearer

For straightforward cases, traditional Python might be more readable:

```python
# Maybe is overkill here
value = Maybe.from_value(config.get("key"))
if value.is_some():
    use(value.unwrap())

# Just use if/else
if "key" in config:
    use(config["key"])
```

Use your judgment. If the Maybe version isn't clearer, stick with plain Python.

### Performance-Critical Code

Maybe adds a small overhead from wrapping and unwrapping values. In tight loops or performance-critical sections, direct `None` checks might be faster. Profile your code before optimizing - the readability benefits are usually worth the tiny performance cost.

### Working with Non-FP Libraries

When you're interfacing with libraries that expect `None`, using Maybe requires constant conversion. Sometimes it's better to work with the library's conventions and convert to Maybe only at your boundaries.

---

## See Also

Once you're comfortable with Maybe, these topics will help you build on your understanding:

- **[Result Monad](/docs/monads/result)** - Learn when to use Result instead of Maybe for error handling
- **[Validation Monad](/docs/monads/validation)** - Understand how to accumulate multiple errors
- **[Error Handling Guide](/docs/guides/error-handling)** - Practical patterns for real-world applications
- **[Maybe API Reference](/docs/api/monads/maybe)** - Complete API documentation for all methods

Remember: Maybe is about making the absence of values explicit and safe. Start using it in places where you'd normally return `None`, and you'll quickly see how it makes your code more robust and self-documenting.
