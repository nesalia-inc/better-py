---
title: AsyncMaybe Monad
description: Asynchronous optional values for operations that might not return a result
---

# AsyncMaybe Monad

AsyncMaybe is the asynchronous version of the Maybe monad. It represents an operation that will complete asynchronously and might not return a value. Think of it as a promise that either delivers a value or tells you "nothing's there" - but unlike a regular promise, you can't accidentally use a value that doesn't exist.

## Why AsyncMaybe Exists

When you're working with async code, you often encounter situations where an operation might not produce a result. A database query might not find a matching record, a cache lookup might miss, or a search might return zero results. In synchronous code, you'd use `None` to represent this, but that leads to the same problems: you need to remember to check for `None` everywhere, and it's easy to forget.

AsyncMaybe wraps the result of an async operation in a container that explicitly represents the possibility of absence. This forces you to handle the "nothing found" case explicitly, which prevents null pointer errors and makes your code's intent clear.

The async version is particularly important because async operations often involve I/O that can fail or return no results. Network requests time out, database connections drop, and cache entries expire. AsyncMaybe gives you a structured way to handle these cases without nested try/except blocks or manual None checks.

<Callout type="success" title="Use AsyncMaybe when:">

- Querying a database where no results might be found
- Fetching from a cache where misses are expected
- Calling an API that might return no results
- Searching through resources where matches aren't guaranteed
- Any async operation where "no value" is a valid outcome

</Callout>

## How AsyncMaybe Works

AsyncMaybe works just like the regular Maybe monad, but it's designed for async operations. When you call an async function that returns an AsyncMaybe, you get back a container that's either `Some` (holding a value) or `Nothing` (empty).

The key difference from regular Maybe is that you typically await the async operation first, then work with the Maybe container. This means you can chain multiple async operations together, and each step only runs if the previous one succeeded. If any step returns Nothing, the rest of the chain is short-circuited and you get Nothing as the final result.

This pattern is incredibly powerful for async workflows because it eliminates the need for nested if statements or manual None checking after each async operation. You can express complex async logic as a linear chain of operations.

## Creating AsyncMaybe Values

There are three ways to create an AsyncMaybe value, depending on your use case.

When you know a value exists, use `AsyncMaybe.some()` to wrap it:

```python
from better_py import AsyncMaybe

async def get_default_user() -> AsyncMaybe[User]:
    default = User(id=0, name="Guest")
    return AsyncMaybe.some(default)
```

When you want to explicitly represent the absence of a value, use `AsyncMaybe.nothing()`:

```python
async def find_guest_user() -> AsyncMaybe[User]:
    # Guest users don't exist in the database
    return AsyncMaybe.nothing()
```

The most common pattern is to use `AsyncMaybe.from_value()` to convert an existing value (which might be None) into an AsyncMaybe:

```python
async def fetch_user(user_id: int) -> AsyncMaybe[User]:
    # Database query returns None if not found
    user = await db.find_user(user_id)
    return AsyncMaybe.from_value(user)
```

The `from_value()` method checks if the value is None and automatically creates Nothing if it is, or Some if it isn't. This is perfect for wrapping database queries, API calls, or any async operation that might return None.

## Transforming AsyncMaybe

Once you have an AsyncMaybe value, you can transform it using methods like `map()` and `bind()`. These methods work just like their synchronous counterparts, but they're designed to work with async operations.

The `map()` method transforms the value inside the AsyncMaybe if it exists:

```python
async def get_user_email(user_id: int) -> AsyncMaybe[str]:
    return (
        AsyncMaybe.from_value(await db.find_user(user_id))
        .map(lambda user: user.email)
    )
```

If the AsyncMaybe is Nothing, the map operation is skipped and Nothing is returned. This means you don't need to manually check if a value exists before transforming it.

The `bind()` method (also called `and_then()`) is for chaining operations that themselves return AsyncMaybe values. This is perfect for chaining multiple async queries or operations:

```python
async def get_user_profile_link(user_id: int) -> AsyncMaybe[str]:
    return (
        AsyncMaybe.from_value(await db.find_user(user_id))
        .bind(lambda user: db.find_profile(user.profile_id))
        .map(lambda profile: profile.url)
    )
```

In this example, if the user isn't found, the profile lookup is never executed. The Nothing from the first operation propagates through the entire chain. This short-circuiting behavior is what makes AsyncMaybe so powerful for composing async operations.

## Real-World Example: Caching Database Queries

Let's look at a realistic example that shows the power of AsyncMaybe. Imagine you're building a web application that fetches user profiles, and you want to check a cache first before hitting the database:

```python
from better_py import AsyncMaybe

async def get_user_profile(user_id: int) -> AsyncMaybe[dict]:
    # Try cache first
    cached = await cache.get(f"user:{user_id}")
    if cached is not None:
        return AsyncMaybe.some(json.loads(cached))

    # Cache miss - fetch from database
    user = await db.find_user(user_id)
    if user is None:
        return AsyncMaybe.nothing()

    # Fetch profile from separate service
    profile = await api.get_profile(user.profile_id)
    if profile is None:
        return AsyncMaybe.nothing()

    # Combine and cache the result
    result = {
        "name": user.name,
        "email": user.email,
        "bio": profile.bio,
        "avatar": profile.avatar_url
    }

    await cache.set(f"user:{user_id}", json.dumps(result))
    return AsyncMaybe.some(result)
```

This works, but look at all those manual None checks and early returns. Here's the same logic using AsyncMaybe's chaining:

```python
from better_py import AsyncMaybe

async def get_user_profile(user_id: int) -> AsyncMaybe[dict]:
    return (
        # Try cache first
        AsyncMaybe.from_value(await cache.get(f"user:{user_id}"))
        .bind(lambda cached: (
            # Cache hit - parse and return
            AsyncMaybe.some(json.loads(cached))
            if cached is not None
            else AsyncMaybe.nothing()
        ))
        .or_else(lambda: (
            # Cache miss - fetch from database
            AsyncMaybe.from_value(await db.find_user(user_id))
            .bind(lambda user: (
                # Fetch profile from API
                AsyncMaybe.from_value(await api.get_profile(user.profile_id))
                .map(lambda profile: ({
                    "name": user.name,
                    "email": user.email,
                    "bio": profile.bio,
                    "avatar": profile.avatar_url
                }))
            ))
        ))
        .map(lambda result: (
            # Cache the result before returning
            asyncio.create_task(
                cache.set(f"user:{user_id}", json.dumps(result))
            ),
            result
        )[1])
    )
```

This version is more declarative and makes the flow clearer. Each step only runs if the previous step succeeded, and errors or missing values automatically short-circuit the chain.

<Callout type="info" title="Good to know">

The `or_else()` method (also called `otherwise()`) lets you provide an alternative AsyncMaybe value if the current one is Nothing. This is perfect for implementing fallback logic like cache-aside patterns.

</Callout>

## Extracting Values

Eventually, you'll need to get the value out of the AsyncMaybe container. The safest way to do this is with `unwrap_or()`, which lets you provide a default value:

```python
async def display_user(user_id: int) -> None:
    maybe_user = await get_user_profile(user_id)
    profile = maybe_user.unwrap_or({"name": "Unknown", "email": "N/A"})
    print(f"Profile: {profile['name']} ({profile['email']})")
```

If you're certain that a value exists, you can use `unwrap()` to extract it directly. However, this will raise an exception if called on Nothing, so only use it after you've verified the value exists:

```python
async def update_user_email(user_id: int, new_email: str) -> bool:
    maybe_user = await get_user_profile(user_id)
    if maybe_user.is_some():
        user = maybe_user.unwrap()
        await db.update_user(user_id, email=new_email)
        return True
    return False
```

<Callout type="warning" title="Warning">

Don't use `unwrap()` in library code or functions that other developers will call. It forces your users to handle exceptions, which defeats the purpose of using AsyncMaybe in the first place. Always return the AsyncMaybe value and let the caller decide how to extract it safely.

</Callout>

## Common Mistakes

### Mistake 1: Unwrapping too early

A common mistake is to unwrap the AsyncMaybe immediately after getting it, which defeats the purpose of using the monad:

```python
# DON'T
async def get_user_name(user_id: int) -> str:
    user = (await get_user_profile(user_id)).unwrap()  # Crashes if not found!
    return user["name"]

# DO
async def get_user_name(user_id: int) -> AsyncMaybe[str]:
    return (await get_user_profile(user_id)).map(lambda u: u["name"])
```

By keeping the value wrapped in AsyncMaybe, you maintain the safety and composability benefits. The caller can decide how to handle the Nothing case.

### Mistake 2: Mixing sync and async operations

AsyncMaybe is designed for async operations. If you're working with synchronous code, use the regular Maybe monad instead:

```python
# DON'T - mixing sync and async unnecessarily
def get_user_sync(user_id: int) -> Maybe[User]:
    user = db.find_user_sync(user_id)  # Sync operation
    return AsyncMaybe.from_value(asyncio.coroutine(lambda: user)())  # Awkward

# DO - use Maybe for sync operations
def get_user_sync(user_id: int) -> Maybe[User]:
    user = db.find_user_sync(user_id)
    return Maybe.from_value(user)
```

### Mistake 3: Forgetting to await async operations

When chaining operations with bind(), remember that the function you pass to bind() should return an AsyncMaybe, not a coroutine:

```python
# DON'T - returning a coroutine instead of AsyncMaybe
async def get_profile(user_id: int) -> AsyncMaybe[Profile]:
    return (
        AsyncMaybe.from_value(await db.find_user(user_id))
        .bind(lambda user: fetch_profile(user.profile_id))  # Returns coroutine!
    )

# DO - await the async operation
async def get_profile(user_id: int) -> AsyncMaybe[Profile]:
    return (
        AsyncMaybe.from_value(await db.find_user(user_id))
        .bind(lambda user: AsyncMaybe.from_value(
            asyncio.create_task(fetch_profile(user.profile_id)).result()
        ))
    )
```

## When NOT to Use AsyncMaybe

AsyncMaybe is a powerful tool, but it's not always the right choice.

**For simple cases, if/else is clearer:** If you just need to check a single async condition and handle the result, a simple if statement might be more readable than AsyncMaybe:

```python
# AsyncMaybe is overkill here
async def check_admin(user_id: int) -> bool:
    return (await get_user_profile(user_id)).map(
        lambda u: u.get("is_admin", False)
    ).unwrap_or(False)

# Just use if/else
async def check_admin(user_id: int) -> bool:
    user = await get_user_profile(user_id)
    return user.get("is_admin", False) if user else False
```

**When working with non-async code:** If you're not doing async operations, use the regular Maybe monad. AsyncMaybe adds unnecessary complexity when everything is synchronous.

**When performance is critical:** AsyncMaybe has a small overhead from the wrapper objects and method calls. In extremely performance-critical code paths, direct None checking might be faster. However, this is rarely a concern in I/O-bound async code.

## Comparing AsyncMaybe to Regular Maybe

AsyncMaybe and regular Maybe serve the same purpose - representing optional values - but they're designed for different contexts.

**Use regular Maybe** when you're working with synchronous code. It's simpler and has no async overhead.

**Use AsyncMaybe** when you're working with async operations. It integrates seamlessly with async/await syntax and is designed for composing async workflows.

The API is nearly identical between the two, so converting from one to the other is straightforward. If you find yourself frequently mixing sync and async code, consider whether you should make everything async for consistency.

---

## See Also

- [Maybe Monad](/docs/monads/maybe) - Synchronous optional values
- [AsyncResult](/docs/monads/async/async-result) - Async error handling
- [Async Monads Overview](/docs/monads/async) - Introduction to async monads
