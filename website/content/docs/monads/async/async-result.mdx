---
title: AsyncResult Monad
description: Asynchronous error handling for operations that can fail
---

# AsyncResult Monad

AsyncResult is the asynchronous version of the Result monad. It represents an operation that will complete asynchronously and can either succeed with a value or fail with an error. Think of it as a structured way to handle exceptions in async code - instead of letting errors propagate up the call stack, you explicitly handle success and failure cases.

## Why AsyncResult Exists

Async code is error-prone by nature. Network requests time out, database connections fail, external services go down, and file operations encounter permissions errors. Python's traditional approach is to use exceptions, but this has several problems in async contexts.

When you use exceptions in async code, you need to wrap every async operation in try/except blocks. This leads to deeply nested code that's hard to read and maintain. Even worse, it's easy to forget to handle an exception, which causes your entire async workflow to fail unexpectedly.

AsyncResult wraps the result of an async operation in a container that explicitly represents success or failure. This forces you to handle errors explicitly, which makes your code more predictable and easier to reason about. Instead of exceptions bubbling up unexpectedly, errors are values that you can transform, recover from, or pass along to callers.

The async version is particularly important because async operations involving I/O are much more likely to fail than synchronous operations. Network requests can time out, databases can be unavailable, and external APIs can return errors. AsyncResult gives you a structured way to handle these failures without complex try/except nesting.

<Callout type="success" title="Use AsyncResult when:">

- Making HTTP requests or API calls that might fail
- Querying databases that might be unavailable or return errors
- Reading or writing files that might not exist or have permission issues
- Calling external services that might be down or return errors
- Any async operation where failures are exceptional but expected

</Callout>

## How AsyncResult Works

AsyncResult works just like the regular Result monad, but it's designed for async operations. When you call an async function that returns an AsyncResult, you get back a container that's either `Ok` (holding a successful value) or `Error` (holding an error).

The key difference from regular exception handling is that errors are values, not control flow. This means you can pass them around, transform them, and decide how to handle them at the appropriate level of your code. An error doesn't crash your program unless you explicitly choose to let it.

When you chain multiple async operations together using `bind()`, errors automatically short-circuit the chain. If any operation fails, the rest of the chain is skipped and the error propagates through. This is similar to how exceptions work, but much more explicit and predictable.

## Creating AsyncResult Values

There are two ways to create an AsyncResult value, depending on whether the operation succeeded or failed.

When an operation succeeds, use `AsyncResult.ok()` to wrap the successful value:

```python
from better_py import AsyncResult

async def fetch_user(user_id: int) -> AsyncResult[User, str]:
    user = await db.find_user(user_id)
    return AsyncResult.ok(user)
```

When an operation fails, use `AsyncResult.error()` to wrap the error:

```python
async def fetch_user(user_id: int) -> AsyncResult[User, str]:
    try:
        user = await db.find_user(user_id)
        return AsyncResult.ok(user)
    except DBError as e:
        return AsyncResult.error(f"Database error: {e}")
```

The most common pattern is to wrap existing async functions that might raise exceptions:

```python
async def safe_api_call(url: str) -> AsyncResult[dict, str]:
    try:
        response = await httpx.get(url)
        return AsyncResult.ok(response.json())
    except httpx.TimeoutError:
        return AsyncResult.error("Request timed out")
    except httpx.HTTPError as e:
        return AsyncResult.error(f"HTTP error: {e}")
```

This pattern converts exceptions into explicit error values, which makes your async code more predictable and easier to debug.

## Transforming AsyncResult

Once you have an AsyncResult value, you can transform it using methods like `map()` and `bind()`. These methods work just like their synchronous counterparts, but they're designed to work with async operations.

The `map()` method transforms the successful value if the operation succeeded:

```python
async def get_user_name(user_id: int) -> AsyncResult[str, str]:
    return (
        await fetch_user(user_id)
        .map(lambda user: user.name)
    )
```

If the AsyncResult is an Error, the map operation is skipped and the error is passed through unchanged. This means you don't need to manually check for errors before transforming the value.

The `bind()` method (also called `and_then()`) is for chaining operations that themselves return AsyncResult values. This is perfect for chaining multiple async operations where any step can fail:

```python
async def get_user_profile(user_id: int) -> AsyncResult[dict, str]:
    return (
        await fetch_user(user_id)
        .bind(lambda user: fetch_profile(user.profile_id))
        .map(lambda profile: ({
            "name": user.name,
            "bio": profile.bio,
            "avatar": profile.avatar_url
        }))
    )
```

In this example, if fetching the user fails, the profile fetch is never executed. The Error from the first operation propagates through the entire chain. This short-circuiting behavior is what makes AsyncResult so powerful for composing async operations.

## Handling Errors

AsyncResult provides several methods for handling errors explicitly.

The `map_error()` method lets you transform errors without touching successful values:

```python
async def get_user_with_friendly_errors(user_id: int) -> AsyncResult[User, str]:
    return (
        await fetch_user(user_id)
        .map_error(lambda e: f"Failed to fetch user: {e}")
    )
```

The `or_else()` method (also called `otherwise()`) lets you provide a fallback AsyncResult value if the current one is an Error:

```python
async def get_user_with_fallback(user_id: int) -> AsyncResult[User, str]:
    return (
        await fetch_user(user_id)
        .or_else(lambda error: fetch_from_cache(user_id))
    )
```

This is perfect for implementing retry logic or fallback strategies. If the primary operation fails, you can try an alternative approach.

## Real-World Example: API Client with Retries

Let's look at a realistic example that shows the power of AsyncResult. Imagine you're building an API client that needs to fetch data from an external service, with retries and fallback logic:

```python
from better_py import AsyncResult
import asyncio

async def fetch_with_retry(
    url: str,
    max_retries: int = 3,
    retry_delay: float = 1.0
) -> AsyncResult[dict, str]:
    """Fetch data from an API with automatic retries on failure."""

    async def attempt(attempt_number: int) -> AsyncResult[dict, str]:
        try:
            response = await httpx.get(url, timeout=5.0)
            return AsyncResult.ok(response.json())
        except httpx.TimeoutError:
            return AsyncResult.error(
                f"Timeout on attempt {attempt_number}"
            )
        except httpx.HTTPError as e:
            return AsyncResult.error(
                f"HTTP error on attempt {attempt_number}: {e}"
            )
        except Exception as e:
            return AsyncResult.error(
                f"Unexpected error on attempt {attempt_number}: {e}"
            )

    # Try the first attempt
    result = await attempt(1)
    if result.is_ok():
        return result

    # Retry with exponential backoff
    for i in range(2, max_retries + 1):
        await asyncio.sleep(retry_delay * (2 ** (i - 2)))
        result = await attempt(i)
        if result.is_ok():
            return result

    # All retries failed - return the last error
    return result
```

Now let's use this retry logic in a more complex workflow that fetches a user profile and enriches it with data from multiple services:

```python
async def get_enriched_user_profile(user_id: int) -> AsyncResult[dict, str]:
    """Fetch and enrich a user profile from multiple services."""

    return (
        # Step 1: Fetch user from database
        await fetch_user_from_db(user_id)
        .bind(lambda user: (
            # Step 2: Fetch preferences from API with retries
            fetch_with_retry(f"https://api.example.com/users/{user_id}/prefs")
            .map(lambda prefs: (user, prefs))
        ))
        .bind(lambda data: (
            # data is (user, prefs)
            user, prefs = data
            # Step 3: Fetch activity history
            fetch_with_retry(f"https://api.example.com/users/{user_id}/activity")
            .map(lambda activity: (user, prefs, activity))
        ))
        .map(lambda data: (
            # data is (user, prefs, activity)
            user, prefs, activity = data
            # Combine all the data
            {
                "id": user.id,
                "name": user.name,
                "email": user.email,
                "preferences": prefs,
                "recent_activity": activity[-10:],  # Last 10 activities
                "enriched_at": datetime.now().isoformat()
            }
        ))
        .map_error(lambda error: (
            f"Failed to enrich user profile for {user_id}: {error}"
        ))
    )
```

This code is clean, declarative, and handles errors at every step. If any step fails, the error propagates automatically and the rest of the chain is skipped. No nested try/except blocks, no manual error checking after each operation, just clear linear code that reads like a story.

<Callout type="info" title="Good to know">

The `bind()` method automatically handles async operations, so you don't need to manually await inside the lambda. The async function you pass to bind() should return an AsyncResult, and the monad takes care of the rest.

</Callout>

## Extracting Values

Eventually, you'll need to get the value out of the AsyncResult container. The safest way to do this is with `unwrap_or()`, which lets you provide a fallback value for the error case:

```python
async def display_user_profile(user_id: int) -> None:
    result = await get_enriched_user_profile(user_id)
    profile = result.unwrap_or({"error": "Failed to load profile"})
    print(f"Profile: {profile}")
```

If you need different behavior for success and error cases, use pattern matching (Python 3.10+) or the `match()` method:

```python
async def handle_user_profile(user_id: int) -> str:
    result = await get_enriched_user_profile(user_id)

    if result.is_ok():
        profile = result.unwrap()
        return f"Success: {profile['name']}"
    else:
        error = result.unwrap_error()
        return f"Failed: {error}"
```

If you're certain that a value exists, you can use `unwrap()` to extract it directly. However, this will raise an exception if called on an Error, so only use it after you've verified the result is ok:

```python
async def update_user_email(user_id: int, new_email: str) -> bool:
    result = await fetch_user_from_db(user_id)
    if result.is_ok():
        user = result.unwrap()
        await db.update_user(user.id, email=new_email)
        return True
    return False
```

<Callout type="warning" title="Warning">

Don't use `unwrap()` in library code or functions that other developers will call. It forces your users to handle exceptions, which defeats the purpose of using AsyncResult in the first place. Always return the AsyncResult value and let the caller decide how to extract it safely.

</Callout>

## Common Mistakes

### Mistake 1: Swallowing errors silently

A common mistake is to use `unwrap_or()` and ignore errors, which hides problems:

```python
# DON'T - silently swallowing errors
async def get_user_name(user_id: int) -> str:
    result = await fetch_user(user_id)
    return result.unwrap_or("Unknown")  # Error is lost!

# DO - preserve the error information
async def get_user_name(user_id: int) -> AsyncResult[str, str]:
    return (await fetch_user(user_id)).map(lambda user: user.name)
```

By returning the AsyncResult, you let the caller decide how to handle the error. They can log it, show it to the user, or recover from it.

### Mistake 2: Converting errors to exceptions

Another mistake is to convert errors back into exceptions, which defeats the purpose of using AsyncResult:

```python
# DON'T - converting to exceptions
async def get_user(user_id: int) -> User:
    result = await fetch_user(user_id)
    if result.is_error():
        raise Exception(result.unwrap_error())  # Back to exceptions!
    return result.unwrap()

# DO - keep the error as a value
async def get_user(user_id: int) -> AsyncResult[User, str]:
    return await fetch_user(user_id)
```

The whole point of AsyncResult is to avoid exceptions. Keep errors as values and handle them explicitly.

### Mistake 3: Forgetting to chain errors

When using `map()`, remember that errors are automatically passed through. Don't manually check for errors:

```python
# DON'T - manually checking for errors
async def get_user_email(user_id: int) -> AsyncResult[str, str]:
    result = await fetch_user(user_id)
    if result.is_ok():
        return AsyncResult.ok(result.unwrap().email)
    else:
        return result  # Manually passing the error

# DO - let map handle it automatically
async def get_user_email(user_id: int) -> AsyncResult[str, str]:
    return (await fetch_user(user_id)).map(lambda user: user.email)
```

The `map()` method automatically skips the transformation if the result is an Error, so you don't need to manually check.

## When NOT to Use AsyncResult

AsyncResult is a powerful tool, but it's not always the right choice.

**For truly exceptional errors:** Some errors are so exceptional that they should crash your program. For example, if you're out of memory or there's a bug in your logic, an exception is appropriate. AsyncResult is for errors that are expected and recoverable.

**For simple scripts:** In throwaway scripts or simple tools, try/except might be simpler than AsyncResult. The overhead of wrapping everything in AsyncResult isn't worth it for code that will only run once or twice.

**When working with non-async code:** If you're not doing async operations, use the regular Result monad. AsyncResult adds unnecessary complexity when everything is synchronous.

**When performance is critical:** AsyncResult has a small overhead from the wrapper objects and method calls. In extremely performance-critical code paths, exceptions might be faster. However, this is rarely a concern in I/O-bound async code.

## Comparing AsyncResult to Regular Result

AsyncResult and regular Result serve the same purpose - error handling - but they're designed for different contexts.

**Use regular Result** when you're working with synchronous code. It's simpler and has no async overhead.

**Use AsyncResult** when you're working with async operations. It integrates seamlessly with async/await syntax and is designed for composing async workflows.

The API is nearly identical between the two, so converting from one to the other is straightforward. If you find yourself frequently mixing sync and async code, consider whether you should make everything async for consistency.

## AsyncResult vs Exceptions

Python's built-in exception handling works well for many cases, but AsyncResult offers several advantages in async code:

**Explicit error handling:** With AsyncResult, you can see from the type signature that a function might fail. With exceptions, you need to read the documentation or code to know what exceptions might be raised.

**Composable:** You can chain multiple async operations together and errors automatically propagate. With exceptions, you need nested try/except blocks that make code hard to read.

**Recoverable:** Errors are values that you can transform, log, or recover from. With exceptions, once an exception is raised, it's hard to recover and continue execution.

**Predictable:** With AsyncResult, errors don't crash your code unless you explicitly let them. With exceptions, a forgotten except clause can crash your entire program.

That said, exceptions are appropriate for truly exceptional conditions - things that should never happen in normal operation (like running out of memory or a bug in your code). AsyncResult is for errors that are expected and recoverable (like a network timeout or missing file).

---

## See Also

- [Result Monad](/docs/monads/result) - Synchronous error handling
- [AsyncMaybe](/docs/monads/async/async-maybe) - Async operations that might not return a value
- [Async Monads Overview](/docs/monads/async) - Introduction to async monads
