---
title: Monads Overview
description: Complete guide to all 13 monads in better-py
---

import { Box, AlertCircle, CheckCircle, Database, Zap } from 'lucide-react';

# Monads in better-py

Monads are one of those concepts that sounds intimidating but is actually quite practical. In better-py, we've implemented monads as **objects that represent computational contexts** - error handling, optional values, state management, and more. Think of them as design patterns that help you structure your code more safely and predictably.

<Cards>
  <Card
    icon={<CheckCircle />}
    title="Maybe"
    href="/docs/monads/maybe"
    description="Handle optional values without None checks"
  />
  <Card
    icon={<AlertCircle />}
    title="Result"
    href="/docs/monads/result"
    description="Explicit error handling without exceptions"
  />
  <Card
    icon={<Zap />}
    title="Validation"
    href="/docs/monads/validation"
    description="Accumulate multiple validation errors"
  />
  <Card
    icon={<Database />}
    title="All Monads"
    href="/docs/monads"
    description="Explore all 13 monads"
  />
</Cards>

---

## What is a Monad?

The term "monad" comes from category theory, but you don't need to understand abstract mathematics to use them effectively. Think of a monad as a **container with special rules** for how you interact with what's inside.

Every monad does three things:

1. **Wraps values in a context** - A value isn't just a value anymore; it's a value that carries additional meaning (like "this might fail" or "this might not exist")
2. **Transforms values safely** - You can apply functions to the wrapped value, and the monad handles the context automatically
3. **Chains operations** - When you have multiple operations that return wrapped values, the monad combines them cleanly

This is abstract, so let's make it concrete. When you use a database lookup, the result might not exist. In regular Python, you'd get `None` back and have to remember to check for it. With a monad (specifically the `Maybe` monad), the possibility of absence is built into the type itself. You can't forget to handle it.

<Callout type="info" title="Don't Fear the Math">

Monads have a reputation for being complex because they're often explained with mathematical notation. In practice, they're just **patterns for handling common scenarios**:
- **Maybe**: Values that might not exist
- **Result**: Operations that can fail with specific errors
- **Validation**: Accumulating multiple errors at once
- **State**: Managing state in a functional way

If you've used Promises in JavaScript or Futures in Rust, you've already used monads.

</Callout>

---

## Why Use Monads?

Python already has ways to handle these problems. You can use `None` for optional values, exceptions for errors, and regular variables for state. So why bother with monads?

The main benefit is **explicitness**. When a function returns `Maybe[User]`, you know immediately that you might not get a user back. When it returns `Result[User, Error]`, you know it can fail and you'll get information about why. When it just returns `User`, you have to read the documentation or the code to know what might go wrong.

This explicitness makes your code:
- **Safer** - The type system helps you avoid forgetting error cases
- **More readable** - The function signature tells you what can happen
- **Easier to refactor** - When you add error handling, you don't have to change every call site

Monads also help you avoid nested conditionals. Instead of:

```python
user = find_user(id)
if user is not None:
    profile = user.get_profile()
    if profile is not None:
        avatar = profile.get_avatar()
        if avatar is not None:
            return avatar.url
return None
```

You can write:

```python
return (
    find_user(id)
    .bind(lambda u: u.get_profile())
    .bind(lambda p: p.get_avatar())
    .map(lambda a: a.url)
)
```

The monad handles all the `None` checks for you, and the code reads like a description of what you're trying to accomplish.

---

## All Monads in better-py

better-py includes 13 monads divided into three categories based on what they help you manage.

### Error Handling Monads

These monads help you handle things going wrong in different ways.

| Monad | Purpose | When to Use It |
|-------|---------|----------------|
| **[Maybe](/docs/monads/maybe)** | Optional values | When a value might not exist, and you don't care why |
| **[Result](/docs/monads/result)** | Success/failure | When an operation can fail with specific error types |
| **[Validation](/docs/monads/validation)** | Accumulating errors | When you need to collect ALL errors, not just the first one |
| **[Try](/docs/monads/try)** | Exception handling | When working with code that throws exceptions |
| **[Either](/docs/monads/either)** | Two possibilities | When you have two possible types (not necessarily success/error) |

**Example**: You're building a web API. Use `Result` for database operations (connection errors, not found), `Validation` for form input (show all validation errors at once), and `Try` when calling third-party libraries that throw exceptions.

### State & Computation Monads

These monads help you manage how computations flow through your code.

| Monad | Purpose | When to Use It |
|-------|---------|----------------|
| **[Reader](/docs/monads/reader)** | Dependency injection | When you need to pass dependencies through multiple layers |
| **[Writer](/docs/monads/writer)** | Logging | When you want to accumulate logs or metadata |
| **[State](/docs/monads/state)** | State management | When you need to manage state functionally |
| **[IO](/docs/monads/io)** | Side effects | When you want to make side effects explicit |
| **[Task](/docs/monads/task)** | Lazy computation | When you want to defer execution until explicitly needed |
| **[Unit](/docs/monads/unit)** | Void return | For functions that don't return a value |

**Example**: Use `Reader` to pass database connections and configuration through your application without threading them through every function manually. Use `Writer` when you need to build up a log of operations.

### Async Monads

These are asynchronous versions of the core error handling monads.

| Monad | Purpose | When to Use It |
|-------|---------|----------------|
| **[AsyncMaybe](/docs/monads/async/async-maybe)** | Async optional values | When checking databases or APIs that might not find anything |
| **[AsyncResult](/docs/monads/async/async-result)** | Async error handling | When making API calls or database queries that can fail |

**Example**: When fetching user data from a remote API, use `AsyncResult` to handle both the asynchronous nature and the possibility of failure.

---

## Choosing the Right Monad

Picking the right monad is mostly about asking yourself what you need to represent. Here's a decision tree to help:

<Callout type="info" title="Decision Tree">

**Do you have a value that might not exist?**

Use **[Maybe](/docs/monads/maybe)**. This is for cases where the absence of a value is normal and expected - like searching a dictionary or looking up a user by ID.

**Do you have an operation that can fail with specific errors?**

Use **[Result](/docs/monads/result)**. This is when you need to know WHY something failed - like a database connection error, permission denied, or validation failure.

**Do you need to validate multiple things and show ALL errors?**

Use **[Validation](/docs/monads/validation)**. This is critical for forms where you want to show "Invalid email, password too short, and age required" all at once, not just one at a time.

**Are you working with exception-throwing code?**

Use **[Try](/docs/monads/try)**. This wraps code that might raise exceptions and converts them to a value you can handle explicitly.

**Do you need to pass dependencies through your code?**

Use **[Reader](/docs/monads/reader)**. This eliminates the need to pass database connections, config objects, and loggers through every function manually.

</Callout>

When in doubt, start with `Result` for error handling and `Maybe` for optional values. They cover the majority of use cases.

---

## Common Monad Operations

All monads in better-py share a similar interface. Once you learn one, you can transfer that knowledge to the others.

### Creating Monads

Every monad provides ways to create its different states. For error handling monads, this means creating success and failure states:

```python
from better_py import Maybe, Result

# Maybe - represents optional values
some_value = Maybe.some(42)           # Value exists
no_value = Maybe.nothing()            # Value doesn't exist
from_none = Maybe.from_value(get_value())  # Converts None to Nothing

# Result - represents success or failure
ok_value = Result.ok(42)              # Success
error_value = Result.error("failed")  # Failure
```

### Transforming Values

The `map()` method lets you transform the value inside a monad. If the monad is in an error state, the transformation is skipped:

```python
# Transform a successful value
Maybe.some(5).map(lambda x: x * 2)    # Returns: Maybe(10)
Result.ok(5).map(lambda x: x * 2)     # Returns: Result.ok(10)

# Errors are preserved
Maybe.nothing().map(lambda x: x * 2)  # Returns: Nothing
Result.error("bad").map(lambda x: x * 2)  # Returns: Result.error("bad")
```

This is where monads shine - you can chain transformations without checking for errors at each step. The monad handles it for you.

### Chaining Operations

The `bind()` method (also called `and_then()` or `flat_map()`) chains operations that themselves return monads. This avoids nested monad structures:

```python
def find_user(id: int) -> Maybe[User]:
    return Maybe.from_value(database.query(id))

def get_profile(user: User) -> Maybe[Profile]:
    return Maybe.from_value(user.profile)

# Without bind - creates nested Maybe[Maybe[Profile]]
# With bind - flattens to Maybe[Profile]
profile = find_user(123).bind(get_profile)
```

If `find_user` returns `Nothing`, the `bind()` operation short-circuits and returns `Nothing` immediately. The `get_profile` function never runs.

### Extracting Values

Eventually, you need to get the value out of the monad. There are safe and unsafe ways to do this:

```python
# Unsafe - raises exception if the value doesn't exist
value = Maybe.some(42).unwrap()       # Returns: 42
# Maybe.nothing().unwrap()           # Raises: ValueError

# Safe - provide a default value
value = Maybe.nothing().unwrap_or(0)  # Returns: 0

# Safe - compute a default value
value = Maybe.nothing().unwrap_or_else(lambda: expensive_computation())
```

In general, prefer `unwrap_or()` and `unwrap_or_else()` over `unwrap()`. Only use `unwrap()` when you've already checked that the value exists or in tests where you want failures to be explicit.

---

## Quick Comparison

It's easy to get confused about when to use which monad. Here are the most common comparisons.

### Maybe vs Result

The distinction is simple: do you care WHY something failed, or just THAT it failed?

```python
from better_py import Maybe, Result

# Maybe: We only care if a user exists
user = Maybe.from_value(find_user(123))
name = user.map(lambda u: u.name).unwrap_or("Guest")
# If user is Nothing, we use "Guest" - no error message needed

# Result: We need to know why it failed
user = fetch_user(123)
if user.is_ok():
    name = user.unwrap().name
else:
    error = user.unwrap_error()
    # Error could be "User not found", "Database connection failed", etc.
    logger.error(f"Failed to fetch user: {error}")
```

**Use Maybe when**: A value might not exist and you'll use a default. Absence is normal.
**Use Result when**: An operation can fail and you need to handle different errors differently.

### Result vs Validation

This is about error handling strategy: fail fast vs fail complete.

```python
from better_py import Result, Validation

# Result: Stops at the first error
def validate_form(data: dict) -> Result[ValidData, str]:
    return (
        validate_name(data["name"])
        .bind(lambda _: validate_email(data["email"]))
        .bind(lambda _: validate_age(data["age"]))
    )
# If name is invalid, we never check email or age
# User sees: "Name too short" (fixes it) → "Email invalid" (fixes it) → "Age invalid"

# Validation: Collects all errors
def validate_form(data: dict) -> Validation[ValidData, str]:
    name_result = validate_name(data["name"])
    email_result = validate_email(data["email"])
    age_result = validate_age(data["age"])

    return name_result.ap(email_result).ap(age_result)
# All validations run, collecting all errors
# User sees: "Name too short, Email invalid, Age required" (fixes all at once)
```

**Use Result when**: You want to fail fast - like in a processing pipeline where continuing after an error doesn't make sense.
**Use Validation when**: You want to show all errors at once - like form validation where the user should see everything they need to fix.

---

## Common Patterns

Once you start using monads, you'll find patterns emerging. Here are some that show up frequently.

### Safe Chaining

The most common pattern is chaining multiple operations that might fail:

```python
def process_user(user_id: int) -> Result[ProcessedUser, str]:
    return (
        fetch_user(user_id)
        .bind(validate_user)
        .map(enrich_user)
        .map(format_user)
    )
```

Each step either succeeds and passes its result to the next step, or fails and short-circuits the entire chain. No try/except blocks, no nested conditionals.

### Providing Defaults

Use `or_else()` to provide fallback values or strategies:

```python
# Try multiple sources in order
config = (
    Maybe.from_value(os.getenv("API_KEY"))
    .or_else(Maybe.from_value(read_from_config()))
    .or_else(Maybe.from_value(read_from_vault()))
    .unwrap_or("")  # Empty string if all fail
)
```

### Error Recovery

Use `or_else()` to recover from errors with fallback logic:

```python
def fetch_with_fallback(id: int) -> Result[Data, str]:
    return (
        fetch_from_primary_db(id)
        .or_else(lambda: fetch_from_cache(id))
        .or_else(lambda: fetch_from_backup_db(id))
    )
```

If the primary database fails, try the cache. If that fails, try the backup. Only if all three fail do you return an error.

---

## Learning Path

Monads are easiest to learn in a specific order. We recommend starting with the simplest and building up:

1. **[Maybe](/docs/monads/maybe)** - The simplest monad. Teaches the core concepts without the complexity of error types.
2. **[Result](/docs/monads/result)** - Adds error information. You'll use this constantly in production code.
3. **[Validation](/docs/monads/validation)** - Teaches error accumulation, a different approach to error handling.
4. **[Try](/docs/monads/try)** - Shows how to bridge exception-based code with monadic code.
5. **[Reader](/docs/monads/reader)** - Your first state/computation monad. Teaches dependency injection.
6. **[State](/docs/monads/state)** - Functional state management. More advanced but very powerful.
7. **Others** - Learn these as you need them for specific use cases.

Don't feel like you need to learn all 13 monads before you start using them. Maybe, Result, and Validation cover 80% of use cases. Learn the others when you encounter a problem they solve.

---

## Next Steps

Ready to dive in? Choose your next topic based on what you're working on:

<Cards>
  <Card
    title="Maybe Monad"
    href="/docs/monads/maybe"
    description="Handle optional values safely - start here if you're new to monads"
  />
  <Card
    title="Result Monad"
    href="/docs/monads/result"
    description="Explicit error handling - the workhorse of production code"
  />
  <Card
    title="Validation Monad"
    href="/docs/monads/validation"
    description="Accumulate errors - essential for forms and APIs"
  />
  <Card
    title="Error Handling Guide"
    href="/docs/guides/error-handling"
    description="Practical strategies for real-world applications"
  />
</Cards>
