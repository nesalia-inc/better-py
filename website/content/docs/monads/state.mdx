---
title: State Monad
description: Thread state through computations functionally
---

# State Monad

The **State** monad represents stateful computations in a pure functional way. Instead of using mutable state, you thread state through a chain of operations explicitly.

## Overview

`State[S, A]` is a function from state `S` to a tuple of `(value, new_state)`:
- **value** (`A`) - The result of the computation
- **new_state** (`S`) - The updated state

## Creating State Values

### `State(lambda s: (value, new_state))` - Wrap a State Function

```python
from better_py import State

# A stateful computation
increment = State(lambda count: (count, count + 1))

# Run with initial state
result, new_state = increment.run(0)
result      # 0
new_state   # 1
```

### `State.get()` - Get the Current State

```python
from better_py import State

get_state = State.get()
value, state = get_state.run(42)
value   # 42
state   # 42
```

### `State.put(value)` - Replace the State

```python
from better_py import State

set_state = State.put(100)
value, state = set_state.run(0)
value   # None
state   # 100
```

### `State.modify(f)` - Modify the State

```python
from better_py import State

increment = State.modify(lambda x: x + 1)
value, state = increment.run(5)
value   # None
state   # 6
```

## Running State

### `run(initial)` - Get Value and State

```python
from better_py import State

state = State(lambda s: (s * 2, s + 1))
value, new_state = state.run(5)
value       # 10
new_state   # 6
```

### `eval(initial)` - Get Only the Value

```python
from better_py import State

state = State(lambda s: (s * 2, s + 1))
value = state.eval(5)  # 10
```

### `execute(initial)` - Get Only the Final State

```python
from better_py import State

state = State(lambda s: (s * 2, s + 1))
final_state = state.execute(5)  # 6
```

## Transforming State

### `map(f)` - Transform the Value

```python
from better_py import State

state = State(lambda s: (s, s + 1))
mapped = state.map(lambda x: x * 2)
value, new_state = mapped.run(5)
value       # 10
new_state   # 6
```

### `flat_map(f)` - Chain State Operations

```python
from better_py import State

def increment(s):
    return (s, s + 1)

def double(s):
    return (s * 2, s)

state = State(increment).flat_map(lambda x: State(double))
value, new_state = state.run(5)
value       # 6
new_state   # 6
```

## Real-World Examples

### Counter

```python
from better_py import State

def increment():
    return State.modify(lambda n: n + 1)

def get_count():
    return State.get()

# Chain operations
counter = (increment()
    .flat_map(lambda _: increment())
    .flat_map(lambda _: get_count()))

value, state = counter.run(0)
value   # 2
state   # 2
```

### Stack Operations

```python
from better_py import State

def push(item):
    return State.modify(lambda stack: [item] + stack)

def pop():
    return State.get().flat_map(lambda stack: State.put(stack[1:]).map(lambda _: stack[0]))

def peek():
    return State.get().map(lambda stack: stack[0] if stack else None)

# Stack operations
stack_ops = (push("a")
    .flat_map(lambda _: push("b"))
    .flat_map(lambda _: pop())
    .flat_map(lambda _: push("c"))
    .flat_map(lambda _: peek()))

value, state = stack_ops.run([])
value   # "c"
state   # ["a", "c"]
```

### Key-Value Store

```python
from better_py import State

def get(key):
    return State.get().map(lambda store: store.get(key))

def put(key, value):
    return State.modify(lambda store: {**store, key: value})

def delete(key):
    return State.modify(lambda store: {k: v for k, v in store.items() if k != key})

# Store operations
operations = (put("name", "Alice")
    .flat_map(lambda _: put("age", 30))
    .flat_map(lambda _: get("name"))
    .flat_map(lambda name: put("greeting", f"Hello, {name}"))
    .flat_map(lambda _: get("greeting")))

value, state = operations.run({})
value   # "Hello, Alice"
state   # {"name": "Alice", "age": 30, "greeting": "Hello, Alice"}
```

### Random Number Generator (Pure)

```python
from better_py import State

def next_random():
    return State.get().map(lambda seed: (seed, (seed * 1103515245 + 12345) % 2**31))

def random_int(max_val):
    return (next_random()
        .map(lambda r: r % max_val))

# Generate random numbers
randoms = (random_int(100)
    .flat_map(lambda x1: random_int(100)
        .map(lambda x2: (x1, x2))))

value, state = randoms.run(42)
value   # (42, 1277...)
state   # New seed
```

### Transaction Log

```python
from better_py import State

def add_entry(message):
    return State.modify(lambda log: log + [message])

def get_log():
    return State.get()

# Build transaction log
transaction = (add_entry("Started")
    .flat_map(lambda _: add_entry("Step 1 complete"))
    .flat_map(lambda _: add_entry("Step 2 complete"))
    .flat_map(lambda _: add_entry("Finished"))
    .flat_map(lambda _: get_log()))

value, state = transaction.run([])
value   # ["Started", "Step 1 complete", "Step 2 complete", "Finished"]
state   # Same list
```

## When to Use State

Use **State** when:
- You need to manage state functionally
- You want to avoid mutable variables
- You're building pure functional code
- You need to thread state through operations
- You want explicit state management

**Don't use State** when:
- Mutable state is acceptable (use plain variables)
- State doesn't change between operations
- You're writing simple scripts

## See Also

- [Reader](/docs/monads/reader) - For dependency injection
- [Writer](/docs/monads/writer) - For logging/accumulation
- [IO](/docs/monads/io) - For side effect management
