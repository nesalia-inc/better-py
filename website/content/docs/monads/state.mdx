---
title: State Monad
description: Pure functional state management
---

# State Monad

The State monad lets you work with mutable state in a purely functional way. Instead of modifying variables in place, which breaks referential transparency and makes code hard to reason about, State treats state transitions as functions that take an input state and produce an output state alongside a result. This might seem abstract, but it provides a powerful way to manage changing state while keeping your code pure, testable, and composable.

Think of State as a computation that's waiting for an initial state. When you create State values, you're describing how to transform state: "given state X, I'll produce result Y and new state Z." The actual state doesn't exist yet. You're building up a description of state transitions, then you provide an initial state to run the computation. This separation of description and execution is what makes State powerful: your state operations are pure functions that can be composed, tested, and reused without any actual mutation happening until you explicitly run them.

The State monad is particularly valuable for modeling state machines, game logic, parsers, and any situation where you need to thread state through multiple operations without relying on mutable variables.

## When to Use State

State excels at managing sequential state transformations in pure code. Here are the situations where it's most valuable:

<Callout type="success" title="Use State when:">

- **You need state machines**: Model systems with clear states and transitions (workflows, protocols, game logic)
- **Building parsers**: Track position and context while parsing text or data
- **Implementing algorithms**: Many algorithms naturally involve state (counters, accumulators, temporary storage)
- **Game development**: Manage game state (score, lives, position) without mutable variables
- **Random number generation**: Thread a seed through computations for reproducible randomness

</Callout>

The key benefit of State is that it makes stateful computations pure and testable. Instead of having hidden mutable variables that change over time, State makes the flow of state explicit in the type signature. You can see exactly what state a computation needs and what state it produces, making it easier to understand and reason about your code.

## How State Works

State is really a function disguised as a data structure. Technically, a value of type `State[S, A]` is a function `S -> tuple[A, S]`: it takes a state of type S and returns a tuple containing both a result of type A and a new state of type S. The monad operations let you compose these state-transforming functions together.

When you use `map` to transform a State's result, the state transformation stays the same. When you use `bind` to chain State operations, the state flows from one operation to the next. This is the essence of State: you thread state through a sequence of operations, each producing a result and updating the state.

Imagine you're implementing a counter. In traditional Python, you might write:

```python
count = 0
count += 1
count += 1
doubled = count * 2
# count = 2, doubled = 4
```

This works, but the mutations make the code harder to test and reason about. With State, you write:

```python
def increment() -> State[int, None]:
    return State.modify(lambda n: n + 1)

def double_and_return() -> State[int, int]:
    return (
        State.get()
        .map(lambda n: n * 2)
    )

computation = increment().bind(lambda _: increment()).bind(lambda _: double_and_return())
doubled, final_state = computation.run(0)
# doubled = 4, final_state = 2
```

Each operation explicitly describes how it transforms state. The state flows through the computation, and at the end you get both the final result and the final state. No mutation occurred, but you achieved the same effect.

## Creating State Values

State provides several constructors for common state operations. These are the building blocks you'll use to build up complex stateful computations.

### Getting the current state

When you need to read the current state without modifying it, use `State.get()`:

```python
from better_py import State

getter = State.get()
result, state = getter.run(42)
# result = 42, state = 42
```

`State.get()` produces a State that yields the current state as its result, leaving the state unchanged. This is useful when you want to read the state to compute a value.

### Setting a new state

When you want to replace the current state with a new value, use `State.put()`:

```python
from better_py import State

setter = State.put(100)
result, state = setter.run(0)
# result = None, state = 100
```

`State.put()` creates a State that ignores the input state and sets the state to the given value. The result is `None` because setting state doesn't produce a meaningful value.

### Modifying the current state

Most commonly, you'll want to transform the current state in some way. Use `State.modify()` for this:

```python
from better_py import State

increment = State.modify(lambda x: x + 1)
result, state = increment.run(5)
# result = None, state = 6
```

`State.modify()` takes a function that transforms the state, applies it to the current state, and returns the new state. The result is `None` because modification alone doesn't produce a value. If you need both the modified state and a result, chain `modify` with `get`:

```python
def increment_and_return() -> State[int, int]:
    return (
        State.modify(lambda x: x + 1)
        .bind(lambda _: State.get())
    )

result, state = increment_and_return().run(5)
# result = 6, state = 6
```

This pattern of modifying then reading is so common that it's worth having as a helper function in your codebase.

### Creating from a function

If you have a function that already transforms state, you can wrap it with `State.from_fn()`:

```python
from better_py import State

def transition(current_state: str) -> tuple[str, str]:
    next_state = "done" if current_state == "processing" else "processing"
    return next_state, next_state

state_transition = State.from_fn(transition)
result, new_state = state_transition.run("processing")
# result = "done", new_state = "done"
```

This is useful when you're refactoring existing code to use State, or when you have complex state transitions that are easier to express as functions.

## Working with State

Once you have State values, you'll transform them and chain them together to build complex stateful computations. State supports the standard monadic operations with automatic state threading.

### Transforming results with map

Use `map()` when you want to transform the result without affecting the state:

```python
from better_py import State

state = State.get().map(lambda x: x * 2)
result, final_state = state.run(5)
# result = 10, final_state = 5
```

The `map` operation applies a function to the State's result while preserving the state unchanged. Transforming the result doesn't modify how state transitions happen.

### Chaining stateful computations with bind

When you need to sequence operations where the state flows from one to the next, use `bind()` (also known as `and_then`):

```python
from better_py import State

def increment() -> State[int, None]:
    return State.modify(lambda n: n + 1)

def add_ten() -> State[int, None]:
    return State.modify(lambda n: n + 10)

def increment_then_add_ten() -> State[int, None]:
    return increment().bind(lambda _: add_ten())

result, final_state = increment_then_add_ten().run(0)
# result = None, final_state = 11
```

When you chain State operations with `bind`, the state flows through each operation in sequence. The output state of one operation becomes the input state of the next.

### Combining State with other operations

Sometimes you want to perform a stateful operation, then use its result in a subsequent computation:

```python
from better_py import State

def pop() -> State[list[int], int]:
    """Pop a value from a stack represented as a list"""
    return (
        State.get()
        .bind(lambda stack:
            State.put(stack[1:]).map(lambda _: stack[0])
        )
    )

def push(value: int) -> State[list[int], None]:
    """Push a value onto a stack"""
    return (
        State.get()
        .map(lambda stack: [value] + stack)
        .bind(lambda new_stack: State.put(new_stack))
    )

def push_then_pop(value: int) -> State[list[int], int]:
    return push(value).bind(lambda _: pop())

result, final_state = push_then_pop(42).run([1, 2, 3])
# result = 42, final_state = [1, 2, 3]
```

The state (the stack) flows through each operation. The push operation modifies the state, and the pop operation reads and modifies it further, with the state being threaded automatically through the computation.

## Running State Computations

When you're ready to execute your stateful computation, provide an initial state using the `run()` method:

```python
from better_py import State

def complex_computation() -> State[int, str]:
    return (
        State.modify(lambda n: n + 1)
        .bind(lambda _: State.get())
        .map(lambda n: f"Count: {n}")
    )

result, final_state = complex_computation().run(0)
# result = "Count: 1", final_state = 1
```

The `run()` method takes an initial state and returns a tuple of `(result, final_state)`. This gives you both the outcome of your computation and the final state after all transitions.

<Callout type="info" title="Result vs State">

The State monad always produces both a result and a final state. The result is the primary output of your computation (like a return value), while the state represents the transformed environment. Sometimes they're the same (when you use `State.get()`), sometimes the result is `None` (when you only modify state), and sometimes they're completely different.

</Callout>

## Real-World Patterns

### Implementing a counter

Counters are a simple but realistic use case for State. You might track operations processed, items counted, or errors encountered:

```python
from better_py import State

class Counter:
    """A counter that can be incremented and read"""

    @staticmethod
    def init() -> State[int, None]:
        """Initialize counter at 0"""
        return State.put(0)

    @staticmethod
    def increment() -> State[int, None]:
        """Increment the counter by 1"""
        return State.modify(lambda n: n + 1)

    @staticmethod
    def add(amount: int) -> State[int, None]:
        """Add an amount to the counter"""
        return State.modify(lambda n: n + amount)

    @staticmethod
    def get() -> State[int, int]:
        """Read the current counter value"""
        return State.get()

    @staticmethod
    def reset() -> State[int, None]:
        """Reset counter to 0"""
        return State.put(0)

# Usage: count some items
def count_items(items: list[str]) -> State[int, str]:
    return (
        Counter.init()
        .bind(lambda _: State.sequence([
            Counter.increment() for _ in items
        ]))
        .bind(lambda _: Counter.get())
        .map(lambda count: f"Processed {count} items")
    )

result, final_state = count_items(["a", "b", "c"]).run(0)
# result = "Processed 3 items", final_state = 3
```

The counter state flows through the computation, being incremented once for each item. The State abstraction makes it impossible to forget to thread the counter through, and the entire operation is pure and testable.

### Game state management

Games are naturally stateful: score, lives, position, and game status all change over time. State lets you manage this cleanly:

```python
from better_py import State
from dataclasses import dataclass

@dataclass
class GameState:
    score: int
    lives: int
    level: int
    is_game_over: bool = False

class Game:
    @staticmethod
    def add_points(points: int) -> State[GameState, None]:
        """Add points to the score"""
        return State.modify(
            lambda state: GameState(
                score=state.score + points,
                lives=state.lives,
                level=state.level,
                is_game_over=state.is_game_over
            )
        )

    @staticmethod
    def lose_life() -> State[GameState, None]:
        """Decrease lives by 1"""
        return (
            State.modify(lambda state: GameState(
                score=state.score,
                lives=state.lives - 1,
                level=state.level,
                is_game_over=state.lives - 1 <= 0
            ))
        )

    @staticmethod
    def advance_level() -> State[GameState, None]:
        """Move to the next level"""
        return State.modify(lambda state: GameState(
            score=state.score,
            lives=state.lives,
            level=state.level + 1,
            is_game_over=state.is_game_over
        ))

    @staticmethod
    def get_score() -> State[GameState, int]:
        """Get the current score"""
        return State.get().map(lambda state: state.score)

    @staticmethod
    def is_game_over() -> State[GameState, bool]:
        """Check if the game is over"""
        return State.get().map(lambda state: state.is_game_over)

# Simulate a game session
def play_game() -> State[GameState, str]:
    return (
        Game.add_points(100)
        .bind(lambda _: Game.advance_level())
        .bind(lambda _: Game.add_points(150))
        .bind(lambda _: Game.lose_life())
        .bind(lambda _: Game.add_points(200))
        .bind(lambda _:
            Game.is_game_over().bind(lambda over =>
                Game.get_score().map(lambda score =>
                    f"Game over: {over}, Final score: {score}"
                )
            )
        )
    )

initial_state = GameState(score=0, lives=3, level=1)
result, final_state = play_game().run(initial_state)
# result = "Game over: False, Final score: 450"
# final_state = GameState(score=450, lives=2, level=2, is_game_over=False)
```

Every game operation explicitly transforms the game state. The state flows through the operations automatically, and you end up with both the final state and a human-readable result.

### Stack-based calculator

A stack calculator is a classic example where State shines. You maintain a stack of values, and each operation manipulates that stack:

```python
from better_py import State

type Stack = list[float]

def push(value: float) -> State[Stack, None]:
    """Push a value onto the stack"""
    return State.modify(lambda stack: [value] + stack)

def pop() -> State[Stack, float]:
    """Pop a value from the stack"""
    return (
        State.get()
        .bind(lambda stack:
            State.put(stack[1:]).map(lambda _: stack[0])
        )
    )

def add() -> State[Stack, None]:
    """Add top two values"""
    return (
        pop().bind(lambda b =>
            pop().bind(lambda a =>
                push(a + b)
            )
        )
    )

def subtract() -> State[Stack, None]:
    """Subtract top two values"""
    return (
        pop().bind(lambda b =>
            pop().bind(lambda a =>
                push(a - b)
            )
        )
    )

def multiply() -> State[Stack, None]:
    """Multiply top two values"""
    return (
        pop().bind(lambda b =>
            pop().bind(lambda a =>
                push(a * b)
            )
        )
    )

# Calculate: (5 + 3) * 2 = 16
def calculate() -> State[Stack, float]:
    return (
        push(5.0)
        .bind(lambda _: push(3.0))
        .bind(lambda _: add())
        .bind(lambda _: push(2.0))
        .bind(lambda _: multiply())
        .bind(lambda _: pop())
    )

result, final_stack = calculate().run([])
# result = 16.0, final_stack = []
```

Each operation explicitly describes how it transforms the stack. The State monad handles the tedious work of threading the stack through each operation, ensuring that you never accidentally lose or corrupt the stack.

### Parsing with position tracking

Parsers need to track their position in the input as they parse. State is perfect for this:

```python
from better_py import State
from dataclasses import dataclass

@dataclass
class ParseState:
    input: str
    position: int = 0

    @property
    def current_char(self) -> str | None:
        if self.position >= len(self.input):
            return None
        return self.input[self.position]

    def advance(self, n: int = 1) -> "ParseState":
        return ParseState(
            input=self.input,
            position=self.position + n
        )

type Parser[T] = State[ParseState, T]

def char() -> Parser[str]:
    """Parse a single character"""
    return (
        State.get()
        .bind(lambda state =>
            State.put(state.advance())
            .map(lambda _: state.current_char)
            if state.current_char is not None
            else State.get().map(lambda s: (s, None))
        )
    )

def string(expected: str) -> Parser[str]:
    """Parse a specific string"""
    def parse_string(state: ParseState) -> tuple[Parser[str], str]:
        remaining = state.input[state.position:]
        if remaining.startswith(expected):
            new_state = state.advance(len(expected))
            return (State.put(new_state), expected)
        return (State.put(state), "")

    return State.from_fn(parse_string)

def many[T](parser: Parser[T]) -> Parser[list[T]]:
    """Parse zero or more occurrences"""
    def parse_many(state: ParseState) -> tuple[Parser[list[T]], list[T]]:
        results = []
        current_state = state

        while True:
            result, new_state = parser.run(current_state)
            if result is None:
                break
            results.append(result)
            current_state = new_state
            if current_state.position >= len(current_state.input):
                break

        return (State.put(current_state), results)

    return State.from_fn(parse_many)

# Parse a sequence of digits
def parse_digits() -> Parser[str]:
    digit_parser = (
        char()
        .bind(lambda c:
            State.get().map(lambda s:
                (s, c) if c and c.isdigit() else (s, None)
            )
        )
    )

    return (
        many(digit_parser)
        .map(lambda digits: "".join(digits))
    )

# Usage
initial_state = ParseState(input="hello123world456", position=0)
result, final_state = parse_digits().run(initial_state)
# result = "123", final_state.position = 8 (pointing at 'w')
```

The parser state (input and position) flows through each parsing operation. Each parser can read the current position, advance it, or leave it unchanged. This makes it easy to build complex parsers from simple ones.

## Common Mistakes

### Forgetting to thread state through

It's easy to accidentally break the state chain by not using `bind` properly:

```python
# DON'T: Breaking the state chain
def increment_twice_wrong() -> State[int, None]:
    State.modify(lambda n: n + 1)  # State is lost!
    State.modify(lambda n: n + 1)  # Operates on original state
    return State.value(None)

# DO: Proper state threading
def increment_twice_correct() -> State[int, None]:
    return (
        State.modify(lambda n: n + 1)
        .bind(lambda _: State.modify(lambda n: n + 1))
    )
```

Every stateful operation must be connected to the chain using `bind` or one of the combinators. If you call a State function without binding it, its state updates will be lost.

### Using State for simple mutations

Not all mutable state needs State. For isolated mutations, regular variables are clearer:

```python
# DON'T: State is overkill here
def sum_list(nums: list[int]) -> int:
    def sum_with_state() -> State[int, int]:
        return (
            State.put(0)
            .bind(lambda _:
                State.sequence([
                    State.modify(lambda total: total + n) for n in nums
                ])
            )
            .bind(lambda _: State.get())
        )
    result, _ = sum_with_state().run(0)
    return result

# DO: Simple sum is clearer
def sum_list(nums: list[int]) -> int:
    return sum(nums)
```

Use State when you need to explicitly model and compose state transitions. For simple accumulations, use Python's built-in tools.

### Confusing result and state

Remember that State produces both a result and a final state:

```python
# DON'T: Ignoring the state
def increment_and_get() -> int:
    result, _ = State.modify(lambda n: n + 1).run(0)
    return result  # This is None!

# DO: Get the state after modifying
def increment_and_get() -> State[int, int]:
    return (
        State.modify(lambda n: n + 1)
        .bind(lambda _: State.get())
    )
```

`State.modify()` returns `None` as its result because modification alone doesn't produce a value. If you want the modified state, you need to explicitly read it with `State.get()`.

## When NOT to Use State

State is a powerful tool, but it's not always the right choice. Here are situations where you should consider alternatives:

### For simple state management

If you have a single piece of state that's only used in one place, a regular variable or class attribute is simpler and more straightforward:

```python
# Simple case: use a class
class Counter:
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1
```

State adds complexity, so it's only worth it when you're composing multiple stateful operations or need the purity that State provides.

### For concurrent state access

State is inherently sequential and single-threaded. If you need multiple threads or processes to access shared state, use proper concurrency primitives (locks, queues, atomic operations) rather than State.

### When performance is critical

State adds overhead from function calls and tuple allocations. In performance-critical code, especially in tight loops, direct mutation may be faster. Profile your code to see if State is a bottleneck.

### For UI state

UI frameworks often have their own state management solutions (React's useState, Redux, etc.). Using State with these frameworks can create friction. Work with the framework's conventions instead.

## See Also

- [Reader Monad](/docs/monads/reader) - For dependency injection and environment passing
- [Writer Monad](/docs/monads/writer) - For accumulating logs and auxiliary output
- [State Management Guide](/docs/guides/state-management) - Patterns for managing application state
