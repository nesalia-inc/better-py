---
title: Either Monad
description: Handle two-value alternatives with Left and Right variants
---

The **Either** monad represents a value that can be one of two possibilities. Conventionally, `Left` represents an error and `Right` represents a success. Unlike exceptions, Either makes error paths explicit in your type signatures—errors cannot be ignored or accidentally propagated.

`Either[L, R]` has two variants:
- **`Left(value)`** - Contains a value of type `L` (typically error)
- **`Right(value)`** - Contains a value of type `R` (typically success)

## Creating & Checking

Create Either values using `Left()` and `Right()` constructors. Use `is_left()` and `is_right()` to check which variant you have.

```python
from better_py import Left, Right

# Create values
error = Left("Something went wrong")
success = Right(42)

# Check variants
error.is_left()    # True
error.is_right()   # False
success.is_left()   # False
success.is_right()  # True
```

Checking variants is safe and doesn't require exception handling. Use these methods when you need to branch logic based on success or error.

## Transforming Values

### Transforming Right Values

Apply a function to the Right value. Left passes through unchanged.

```python
Right(5).map(lambda x: x * 2)      # Right(10)
Left("error").map(lambda x: x * 2)  # Left("error")
```

### Transforming Left Values

Apply a function to the Left value. Right passes through unchanged.

```python
Left("error").map_left(str.upper)  # Left("ERROR")
Right(42).map_left(str.upper)      # Right(42)
```

### Swapping Left and Right

```python
Left(1).swap()   # Right(1)
Right(2).swap()  # Left(2)
```

## Chaining Operations

The `flat_map` method chains operations that return Either. If any step returns Left, the rest of the chain is skipped—errors propagate automatically.

```python
from better_py import Left, Right

def validate_positive(x: int):
    return Right(x) if x > 0 else Left("Must be positive")

def validate_non_zero(x: int):
    return Right(x) if x != 0 else Left("Must be non-zero")

def divide(a: int, b: int):
    return (validate_positive(a)
        .flat_map(lambda _: validate_non_zero(b))
        .map(lambda _: a / b))

divide(10, 2)  # Right(5.0)
divide(10, 0)  # Left("Must be non-zero")
divide(-5, 2)  # Left("Must be positive")
```

This replaces nested if/else chains with a flat, readable pipeline.

## Combining Eithers

### Combining Multiple Eithers

Combine multiple Either values into a tuple. Returns the first Left if any.

```python
from better_py import Either, Left, Right

Either.zip(Right(1), Right(2), Right(3))          # Right((1, 2, 3))
Either.zip(Right(1), Left("bad"), Right(3))      # Left("bad")
```

### Applying Wrapped Functions

Apply a function wrapped in an Either to a value wrapped in an Either.

```python
from better_py import Right

add = Right(lambda x: x + 1)
value = Right(5)

value.ap(add)  # Right(6)

Left("bad").ap(add)   # Left("bad")
value.ap(Left("bad")) # Left("bad")
```

### Lifting Regular Functions

Lift regular functions to work with Either values.

```python
from better_py import Either, Right

def add(x, y):
    return x + y

Either.lift2(add, Right(5), Right(10))   # Right(15)
Either.lift2(add, Right(5), Left("bad")) # Left("bad")
```

## Pattern Matching

### Handling Both Cases

Transform both Left and Right into a common result type.

```python
from better_py import Left, Right

def describe(either):
    return either.fold(
        on_left=lambda err: f"Error: {err}",
        on_right=lambda val: f"Value: {val}"
    )

describe(Left("error"))  # "Error: error"
describe(Right(42))      # "Value: 42"
```

## Real-World Pattern: API Response Handling

```python
from better_py import Left, Right

class APIError:
    def __init__(self, message: str, status_code: int):
        self.message = message
        self.status_code = status_code

def fetch_user(user_id: int):
    """Fetch user from API. Returns Either[APIError, dict]."""
    if user_id == 1:
        return Right({"id": 1, "name": "Alice", "email": "alice@example.com"})
    return Left(APIError("User not found", 404))

def validate_email(user: dict):
    """Validate email format. Returns Either[APIError, dict]."""
    if "@" not in user.get("email", ""):
        return Left(APIError("Invalid email", 400))
    return Right(user)

def format_user(user: dict):
    """Format user for display."""
    return f"{user['name']} ({user['email']})"

# Chain operations
result = (fetch_user(1)
    .flat_map(validate_email)
    .map(format_user))

# Right("Alice (alice@example.com)")

# With invalid user
result = (fetch_user(99)
    .flat_map(validate_email)
    .map(format_user))

# Left(APIError("User not found", 404))

# Handle both cases
display = result.fold(
    on_left=lambda err: f"Error {err.status_code}: {err.message}",
    on_right=lambda formatted: formatted
)
```

## When to Use

Use **Either** when:
- You need error values with rich context (custom error types)
- Left/right distinction is meaningful beyond success/error
- You want explicit error handling in your types

**Don't use Either** when:
- You only need optional values (use `Maybe`)
- You need simple error strings (use `Result`)
- You need to accumulate multiple errors (use `Validation`)

## Comparison with Result and Maybe

All three monads handle operations that might not produce a value, but they serve different purposes:

| Feature | Either | Result | Maybe |
|---------|--------|--------|-------|
| **Purpose** | Two distinct possibilities | Error handling | Optional values |
| **Generic types** | `Either[L, R]` (any two types) | `Result[T, E]` (success/error) | `Maybe[T]` (value/none) |
| **Variants** | `Left(value)`, `Right(value)` | `Ok(value)`, `Error(error)` | `Some(value)`, `Nothing` |
| **Error context** | ✅ Any type | ✅ Error type only | ❌ None |
| **Convention** | Generic (flexible) | Success/error specific | Presence/absence |
| **Use case** | Two-value alternatives | Operations that fail | Values that might be missing |

**Examples**:

```python
# Either: Two possibilities with rich error context
Either[APIError, User]  # Left(APIError) or Right(User)

# Result: Success or error with context
Result[User, APIError]  # Ok(User) or Error(APIError("User not found", 404))

# Maybe: Value exists or not
Maybe[User]  # Some(User) or Nothing
```

**Rule of thumb**:
- Use **Either** when Left/right are two distinct possibilities (beyond success/error)
- Use **Result** when you have explicit success/error cases
- Use **Maybe** when a value might simply not exist (no error involved)

## See Also

- [Result](/docs/monads/result) - For explicit error handling
- [Maybe](/docs/monads/maybe) - For optional values
- [Validation](/docs/monads/validation) - For accumulating errors
