---
title: Either Monad
description: Represent one of two possible values
---

# Either Monad

The `Either` monad represents a value that can be one of two types. By convention, we use `Left` for errors and `Right` for success values, but unlike Result, Either is more general - it can represent any two possibilities, not just success and failure.

---

## Understanding Either

Think of Either as a box that contains one of two things, but you don't know which until you look inside. Unlike Maybe (which is "something or nothing") and Result (which is "success or error"), Either is more flexible - it's "this thing or that thing."

The conventional naming comes from functional programming: `Right` is for the "right" or correct value, and `Left` is for the "left" or wrong value. But you can use Either for any two-type situation.

Either is less commonly used than Maybe or Result because most of the time, you either have an optional value (use Maybe) or an error case (use Result). Either shines when you have two equally valid possibilities that aren't "success" and "error."

<Callout type="info" title="Either vs Result">

**Result**: Optimized for success/error cases with helper methods like `map_error()` and specific error handling patterns.
**Either**: More general two-value container for when you have two possible types that aren't necessarily success/error.

Use Result for error handling. Use Either when you need to represent two different types of valid values.

</Callout>

---

## When to Use Either

Either is useful in specific scenarios:

### Two Different Return Types

Sometimes a function can legitimately return one of two different types:

```python
from better_py import Either

# A user might be a regular User or an Admin
def get_account(id: int) -> Either[Admin, User]:
    account = database.query(Account).filter_by(id=id).first()

    if account.is_admin:
        return Either.left(Admin(account))
    else:
        return Either.right(User(account))

# Handle both cases
account = get_account(123)
if account.is_left():
    admin = account.unwrap_left()
    show_admin_dashboard(admin)
else:
    user = account.unwrap_right()
    show_user_dashboard(user)
```

### When Neither Type Is an "Error"

Unlike Result, where one type is clearly an error, Either treats both types as valid:

```python
from better_py import Either

# Parsing can return different AST node types
def parse_node(tokens: List[Token]) -> Either[ExpressionNode, StatementNode]:
    first_token = tokens[0]

    if first_token.type == "KEYWORD":
        return Either.left(StatementNode(tokens))
    else:
        return Either.right(ExpressionNode(tokens))
```

### Migration from Other Languages

If you're coming from Haskell, Scala, or other functional languages, Either is familiar. In those languages, Either is commonly used for error handling. In better-py, we recommend using Result for error cases, but Either is available if you prefer that style.

---

## Creating Either Values

Either provides two ways to create values, one for each possibility.

### Creating a Right Value

By convention, `Right` is for the success or correct value:

```python
from better_py import Either

user = Either.right(User(id=1, name="Alice"))
age = Either.right(30)
```

### Creating a Left Value

By convention, `Left` is for the alternative value (often, but not always, an error):

```python
error = Either.left("User not found")
admin = Either.left(Admin(id=1, name="Bob"))
```

The convention is Left = error/alternative, Right = success/correct. But this is just a convention - Either doesn't enforce it.

---

## Inspecting Either Values

Before you can use an Either value, you need to check which side it contains.

### Checking for Right

The `is_right()` method returns `True` if the Either contains a Right value:

```python
Either.right(42).is_right()     # Returns: True
Either.left("bad").is_right()    # Returns: False
```

### Checking for Left

The `is_left()` method returns `True` if the Either contains a Left value:

```python
Either.right(42).is_left()      # Returns: False
Either.left("bad").is_left()     # Returns: True
```

These two methods are opposites - exactly one will return `True` for any Either value.

---

## Transforming Either Values

Either provides methods to transform both sides of the value.

### Transforming the Right Value

The `map()` method transforms the Right value, leaving Left untouched:

```python
Either.right(5).map(lambda x: x * 2)       # Returns: Either.right(10)
Either.left("bad").map(lambda x: x * 2)    # Returns: Either.left("bad")
```

This works like Result's `map()` - if the Either is Left, the transformation is skipped.

### Transforming the Left Value

The `map_left()` method transforms the Left value, leaving Right untouched:

```python
Either.left("bad").map_left(str.upper)     # Returns: Either.left("BAD")
Either.right(5).map_left(str.upper)        # Returns: Either.right(5)
```

This is useful when you want to modify the Left value without touching the Right value.

### Swapping Sides

The `swap()` method exchanges Left and Right:

```python
Either.right(5).swap()     # Returns: Either.left(5)
Either.left("bad").swap()  # Returns: Either.right("bad")
```

This is occasionally useful when you want to reverse the convention.

---

## Extracting Values from Either

Eventually, you need to get the value out of the Either wrapper.

### Unwrap Either Side

The `unwrap()` method returns whichever value is inside, regardless of side:

```python
Either.right(42).unwrap()     # Returns: 42
Either.left("bad").unwrap()   # Returns: "bad"
```

This doesn't distinguish between the sides - it just gives you the value.

### Unwrap Specific Side

The `unwrap_right()` and `unwrap_left()` methods return the value only if it's on that side:

```python
Either.right(42).unwrap_right()     # Returns: 42
Either.left("bad").unwrap_right()    # Raises: ValueError (not a Right)

Either.left("bad").unwrap_left()     # Returns: "bad"
Either.right(42).unwrap_left()       # Raises: ValueError (not a Left)
```

Use these when you've already checked which side you have and want to extract it safely.

---

## Real-World Examples

### Type Discrimination

When you have data that can be one of several types, Either can represent this:

```python
from better_py import Either

class CreditCard:
    def __init__(self, number: str, expiry: str):
        self.number = number
        self.expiry = expiry

class PayPal:
    def __init__(self, email: str):
        self.email = email

def parse_payment_method(data: dict) -> Either[CreditCard, PayPal]:
    """Parse payment method from API response"""
    if data["type"] == "credit_card":
        return Either.left(CreditCard(data["number"], data["expiry"]))
    elif data["type"] == "paypal":
        return Either.right(PayPal(data["email"]))
    else:
        raise ValueError("Unknown payment type")

# Handle both types
payment = parse_payment_method(api_response)
if payment.is_left():
    card = payment.unwrap_left()
    process_credit_card(card)
else:
    paypal = payment.unwrap_right()
    process_paypal(paypal)
```

### API Version Migration

When migrating between API versions, Either can represent old and new formats:

```python
from better_py import Either

class UserV1:
    def __init__(self, username: str):
        self.username = username

class UserV2:
    def __init__(self, email: str):
        self.email = email

def fetch_user(id: int) -> Either[UserV1, UserV2]:
    """Fetch user, might be V1 or V2 format"""
    data = api.get_user(id)

    if "email" in data:
        return Either.right(UserV2(data["email"]))
    else:
        return Either.left(UserV1(data["username"]))

# Handle both versions
user = fetch_user(123)
if user.is_right():
    # New format
    return user.unwrap_right().email
else:
    # Old format - migrate
    return migrate_to_v2(user.unwrap_left())
```

### Success/Error (When Not Using Result)

You can use Either for error handling, though Result is usually better:

```python
from better_py import Either

class PaymentError:
    def __init__(self, message: str):
        self.message = message

def process_payment(amount: float) -> Either[PaymentError, Receipt]:
    if amount <= 0:
        return Either.left(PaymentError("Invalid amount"))
    if amount > 1000:
        return Either.left(PaymentError("Amount exceeds limit"))

    return Either.right(Receipt(amount))

# Handle it
result = process_payment(100)
if result.is_right():
    receipt = result.unwrap_right()
    print(f"Payment successful: {receipt.id}")
else:
    error = result.unwrap_left()
    print(f"Payment failed: {error.message}")
```

<Callout type="warning" title="Prefer Result for Error Handling">

While Either can be used for error handling, Result is usually better because:
- It has error-specific methods like `map_error()`
- The convention (Ok/Error) is clearer than (Right/Left)
- Better integration with other error handling patterns

Use Result for errors, Either for general two-type situations.

</Callout>

---

## Common Patterns

### Providing Alternatives

The `or_else()` method provides an alternative Either if the first is Left:

```python
def fetch_from_cache(id: int) -> Either[CacheError, Data]:
    ...

def fetch_from_db(id: int) -> Either[DatabaseError, Data]:
    ...

def fetch_data(id: int) -> Either[DatabaseError, Data]:
    return (
        fetch_from_cache(id)
        .or_else(lambda: fetch_from_db(id))
    )
```

If the cache fetch returns a Left (error), try the database.

### Pattern Matching

Python 3.10+ pattern matching works well with Either:

```python
from better_py import Either

def process_payment(payment: Either[CreditCard, PayPal]) -> str:
    match payment:
        case Either(_is_left=True, _value=card):
            return f"Processing credit card ending in {card.number[-4:]}"
        case Either(_is_right=True, _value=paypal):
            return f"Processing PayPal account {paypal.email}"
```

---

## When NOT to Use Either

Either isn't always the right choice.

### For Simple Error Handling, Use Result

```python
# DON'T - Either is less clear for errors
def fetch_user(id: int) -> Either[str, User]:
    if not found:
        return Either.left("User not found")
    return Either.right(user)

# DO - Result is clearer
def fetch_user(id: int) -> Result[User, str]:
    if not found:
        return Result.error("User not found")
    return Result.ok(user)
```

### For Optional Values, Use Maybe

```python
# DON'T - Either is overkill
def find_user(id: int) -> Either[None, User]:
    user = database.query(id)
    if user:
        return Either.right(user)
    return Either.left(None)

# DO - Maybe is simpler
def find_user(id: int) -> Maybe[User]:
    return Maybe.from_value(database.query(id))
```

### For More Than Two Types, Use Other Patterns

If you have more than two possibilities, consider:
- **Union types**: `User | Admin | Guest`
- **Enum with variant data**
- **Polymorphism with base class and subclasses**

Either is specifically for two-type situations.

---

## Either vs Result: A Comparison

The distinction is subtle but important:

```python
from better_py import Either, Result

# Either: Two equally valid types
def get_user_type(id: int) -> Either[Admin, RegularUser]:
    user = database.query(id)
    if user.is_admin:
        return Either.left(Admin(user))
    return Either.right(RegularUser(user))

# Result: Success or failure
def fetch_user(id: int) -> Result[User, Error]:
    try:
        user = database.query(id)
        if user is None:
            return Result.error(Error.NOT_FOUND)
        return Result.ok(user)
    except DatabaseError as e:
        return Result.error(Error.DATABASE_ERROR)
```

Either represents "this thing or that thing." Result represents "success or failure."

---

## See Also

- **[Result Monad](/docs/monads/result)** - For error handling with success/failure states
- **[Maybe Monad](/docs/monads/maybe)** - For optional values that might not exist
- **[Validation Monad](/docs/monads/validation)** - For accumulating multiple errors

Either is a specialized tool. You'll use Maybe and Result more frequently, but Either is invaluable when you need to represent two different types of valid values. Think of it when you find yourself writing functions that can return one of two specific types, and neither is an "error" case.
