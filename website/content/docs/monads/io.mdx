---
title: IO Monad
description: Managing side effects explicitly
---

# IO Monad

The IO monad helps you manage side effects in a purely functional way. Instead of performing side effects immediately when you call a function, IO wraps them in a description that says "this computation will have a side effect when you run it." This separation of description and execution makes your code more predictable, easier to test, and clearer about what effects it produces.

Think of IO as a container for an action that will happen later. When you create an IO value, you're not actually doing anything yet. You're building a description of what will happen. The side effect only occurs when you explicitly call `run()`. This is powerful because it lets you compose complex programs from simple side-effecting operations, with complete control over when and whether those effects occur.

In pure functional programming, side effects are problematic because they break referential transparency. A function that prints to the console or writes to a database doesn't just return a value; it interacts with the outside world. IO makes these effects explicit in the type system. When you see a function returns `IO[A]`, you know immediately that calling it will have some effect on the world. This explicitness is IO's greatest strength.

## When to Use IO

IO is designed for any computation that interacts with the outside world or has observable effects. Here are the most common use cases:

<Callout type="success" title="Use IO when:">

- **You need controlled side effects**: File operations, network calls, database queries, or any I/O
- **Testing code with side effects**: Defer effects until you're ready to execute them in tests
- **Sequencing side effects**: Perform multiple operations in a specific order
- **Managing effect boundaries**: Separate pure code from impure code at your application's edges

</Callout>

The key benefit of IO is that it makes side effects explicit and controllable. Instead of effects happening scattered throughout your code, they're wrapped in IO values that flow through your program. Effects only happen when you explicitly run them, typically at the "edges" of your application where pure code meets the real world.

## How IO Works

IO is really just a wrapper around a function. When you create an IO value, you're wrapping a function that, when called, will produce a value and have some effect on the world. The monad operations let you compose these functions together, building up complex programs from simple side-effecting operations.

The crucial insight is that creating an IO value doesn't execute the side effect. The effect only happens when you call `run()`. This is like writing down a recipe versus actually cooking. You can compose recipes, modify them, share them, and check them for errors without ever turning on the stove.

Imagine you want to read a file. In traditional Python, you might write:

```python
def read_file(path: str) -> str:
    with open(path) as f:
        return f.read()
```

This function immediately reads the file when you call it. The I/O happens implicitly as part of the function call. With IO, you write:

```python
def read_file(path: str) -> IO[str]:
    return IO(lambda: Path(path).read_text())
```

Now calling `read_file()` doesn't read anything. It returns an IO value that describes the read operation. The file only gets read when you call `.run()` on that IO value. This seems like a small difference, but it has profound implications for how you structure and test your code.

## Creating IO Values

IO provides a simple way to wrap side-effecting operations. The most common approach is using the `IO()` constructor, which wraps a function.

### Wrapping side effects

When you have a function or operation that produces side effects, wrap it in IO:

```python
from better_py import IO

# Wrap a print statement
print_hello = IO(lambda: print("Hello, World!"))

# Wrap a file read
read_config = IO(lambda: Path("config.json").read_text())

# Wrap a database query
fetch_users = IO(lambda: db.query("SELECT * FROM users"))
```

Each of these creates an IO value that describes the side effect without executing it. The effect only occurs when you call `.run()` on the IO value.

### Creating from pure values

Sometimes you need to create an IO value from a pure value that doesn't have side effects. Use `IO.pure()` or `IO.value()` for this:

```python
from better_py import IO

# Create an IO that produces a value without effects
greeting = IO.pure("Hello, World!")
result = greeting.run()  # Returns "Hello, World!", no side effects
```

This is useful when you're working with IO operations but need to inject pure values into the flow.

## Working with IO

Once you have IO values, you'll transform them and chain them together to build larger programs. IO supports the standard monadic operations with automatic sequencing of side effects.

### Transforming results with map

Use `map()` when you want to transform the result of an IO operation without adding new effects:

```python
from better_py import IO

read_input = IO(lambda: input("Enter your name: "))

# Transform the input to uppercase
greet_uppercase = read_input.map(lambda name: f"HELLO, {name.upper()}!")

# Run it
result = greet_uppercase.run()
print(result)
```

The `map` operation applies a function to the IO's result after the side effect completes. The transformation itself is pure and doesn't introduce new side effects.

### Sequencing effects with bind

When you need to perform operations where later effects depend on earlier results, use `bind()` (also known as `and_then`):

```python
from better_py import IO

def read_file(path: str) -> IO[str]:
    return IO(lambda: Path(path).read_text())

def write_file(path: str, content: str) -> IO[None]:
    return IO(lambda: Path(path).write_text(content))

def process_file(input_path: str, output_path: str) -> IO[None]:
    return (
        read_file(input_path)
        .bind(lambda content =>
            write_file(output_path, content.upper())
        )
    )

# Run the whole pipeline
process_file("input.txt", "output.txt").run()
```

When you chain IO operations with `bind`, the effects happen in sequence. First the file is read, then it's written. The second operation waits for the first to complete.

### Combining independent operations

Sometimes you have multiple IO operations that don't depend on each other, and you want to combine their results:

```python
from better_py import IO

def fetch_user(user_id: int) -> IO[User]:
    return IO(lambda: database.get_user(user_id))

def fetch_orders(user: User) -> IO[list[Order]]:
    return IO(lambda: database.get_orders(user.id))

def fetch_user_with_orders(user_id: int) -> IO[tuple[User, list[Order]]]:
    return (
        fetch_user(user_id)
        .ap(fetch_user(None))  # This would need adjustment
        # Better approach:
    )

# Actually, for dependent operations, use bind:
def fetch_user_with_orders(user_id: int) -> IO[tuple[User, list[Order]]]:
    return (
        fetch_user(user_id)
        .bind(lambda user =>
            fetch_orders(user)
            .map(lambda orders => (user, orders))
        )
    )
```

The `bind` operation ensures that operations happen in the right order, with later operations receiving the results of earlier ones.

### Running IO operations

When you're ready to execute the side effects, use the `run()` method:

```python
from better_py import IO

def greet_user() -> IO[str]:
    return (
        IO(lambda: print("What is your name?"))
        .bind(lambda _ =>
            IO(lambda: input())
        )
        .map(lambda name: f"Hello, {name}!")
    )

message = greet_user().run()
print(message)
```

The `run()` method executes the side effects and returns the final result. Effects happen in the order they were composed, with each operation completing before the next begins.

## Real-World Patterns

### File processing pipeline

IO excels at building multi-step file operations where each step depends on the previous one:

```python
from better_py import IO
from pathlib import Path

def read_file(path: str) -> IO[str]:
    """Read a file's contents"""
    return IO(lambda: Path(path).read_text())

def write_file(path: str, content: str) -> IO[None]:
    """Write content to a file"""
    return IO(lambda: Path(path).write_text(content))

def backup_file(path: str) -> IO[None]:
    """Create a backup of a file"""
    return (
        read_file(path)
        .bind(lambda content =>
            write_file(f"{path}.bak", content)
        )
    )

def process_json_file(input_path: str, output_path: str) -> IO[None]:
    """Read, validate, transform, and write JSON data"""
    import json

    return (
        read_file(input_path)
        .map(lambda content: json.loads(content))
        .tap(lambda data: IO(lambda: print(f"Processing {len(data)} records")))
        .map(lambda data: {**data, "processed": True})
        .map(lambda data: json.dumps(data, indent=2))
        .bind(lambda transformed: write_file(output_path, transformed))
    )

# Usage
process_json_file("input.json", "output.json").run()
```

Each step in the pipeline is an IO operation. The entire pipeline is composed before any effects happen. When you call `run()`, the steps execute in sequence, with data flowing from one step to the next.

### API interaction

IO is perfect for working with external APIs where you need to sequence multiple requests:

```python
from better_py import IO
import requests

def fetch_user(user_id: int) -> IO[dict]:
    """Fetch user data from API"""
    return IO(lambda: requests.get(f"https://api.example.com/users/{user_id}").json())

def fetch_user_posts(user_id: int) -> IO[list[dict]]:
    """Fetch user's posts from API"""
    return IO(lambda: requests.get(f"https://api.example.com/users/{user_id}/posts").json())

def generate_report(user_id: int) -> IO[str]:
    """Generate a report combining user data and posts"""
    return (
        fetch_user(user_id)
        .tap(lambda user: IO(lambda: print(f"Fetched user: {user['name']}")))
        .bind(lambda user =>
            fetch_user_posts(user_id)
            .map(lambda posts =>
                f"User: {user['name']}\n"
                f"Email: {user['email']}\n"
                f"Posts: {len(posts)}\n"
            )
        )
    )

# Usage
report = generate_report(123).run()
print(report)
```

The API calls are clearly separated and sequenced. You can see exactly what effects will happen and in what order, all before any network requests are made.

### Database operations

IO helps you sequence database operations safely:

```python
from better_py import IO
import sqlite3

def execute_query(query: str, params: tuple) -> IO[list[dict]]:
    """Execute a database query"""
    def _execute():
        conn = sqlite3.connect("database.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute(query, params)
        results = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return results

    return IO(_execute)

def create_user(name: str, email: str) -> IO[int]:
    """Create a new user and return their ID"""
    return (
        execute_query(
            "INSERT INTO users (name, email) VALUES (?, ?)",
            (name, email)
        )
        .bind(lambda _: execute_query("SELECT last_insert_rowid()", ()))
        .map(lambda rows: rows[0]["last_insert_rowid()"])
    )

def get_user_posts(user_id: int) -> IO[list[dict]]:
    """Get all posts for a user"""
    return execute_query(
        "SELECT * FROM posts WHERE user_id = ?",
        (user_id,)
    )

def create_user_with_post(name: str, email: str, post_title: str) -> IO[int]:
    """Create a user and their first post in a transaction"""
    return (
        create_user(name, email)
        .tap(lambda user_id: IO(lambda: print(f"Created user {user_id}")))
        .bind(lambda user_id =>
            execute_query(
                "INSERT INTO posts (user_id, title) VALUES (?, ?)",
                (user_id, post_title)
            )
            .map(lambda _: user_id)
        )
    )

# Usage
user_id = create_user_with_post("Alice", "alice@example.com", "Hello World").run()
print(f"Created user {user_id} with their first post")
```

Database operations are composed into pipelines that execute sequentially. The structure of your computation is clear before any database connections are made.

## Common Mistakes

### Running IO too early

It's tempting to run IO operations as soon as you create them, but this defeats the purpose:

```python
# DON'T: Run immediately
def process_data(data: str) -> str:
    result = expensive_computation(data).run()  # Effect happens now!
    return result.upper()

# DO: Keep it wrapped
def process_data(data: str) -> IO[str]:
    return expensive_computation(data).map(lambda s: s.upper())
```

Keep IO values wrapped until you reach the edge of your application (like a main function or request handler). Let the caller decide when to run effects.

### Ignoring return values

IO operations produce values, and you should use them rather than ignoring them:

```python
# DON'T: Ignore the result
def read_and_process(path: str) -> IO[None]:
    return (
        IO(lambda: Path(path).read_text())
        .map(lambda content: process(content))  # Result is lost!
    )

# DO: Preserve the result
def read_and_process(path: str) -> IO[str]:
    return (
        IO(lambda: Path(path).read_text())
        .map(lambda content: process(content))
    )
```

If you create a value with IO, you should either return it or explicitly indicate why you're discarding it (usually with `tap`).

### Mixing pure and impure code

Don't mix side-effecting code with pure code within IO operations:

```python
# DON'T: Side effects during transformation
def process_list(items: list[str]) -> IO[list[str]]:
    return IO.pure(items).map(lambda lst: print(lst); lst)  # Wrong!

# DO: Separate effects
def process_list(items: list[str]) -> IO[list[str]]:
    return (
        IO.pure(items)
        .tap(lambda lst: IO(lambda: print(f"Processing {len(lst)} items")))
        .map(lambda lst: [item.upper() for item in lst])
    )
```

Keep transformations pure. Side effects should only happen in the IO operations you explicitly create.

## When NOT to Use IO

IO is a powerful tool, but it's not always the right choice. Here are situations where you should consider alternatives:

### For pure computations

If your code doesn't have side effects, don't wrap it in IO. Pure functions are simpler and more composable:

```python
# DON'T: IO for pure code
def add(a: int, b: int) -> IO[int]:
    return IO.pure(a + b)

# DO: Just return the value
def add(a: int, b: int) -> int:
    return a + b
```

Use IO only when you're actually dealing with side effects like I/O, state mutations, or external system calls.

### When you need concurrency

IO operations run sequentially, one after another. If you need to perform multiple I/O operations concurrently, use asyncio or threading instead:

```python
# For concurrent operations, use Task or asyncio
async def fetch_multiple(user_ids: list[int]):
    tasks = [fetch_user_async(id) for id in user_ids]
    return await asyncio.gather(*tasks)
```

IO is for sequencing effects. For concurrency, use tools designed for that purpose.

### In performance-critical code

IO adds a small overhead from function wrapping. In performance-critical inner loops, this overhead might matter. Profile your code to see if IO is a bottleneck before optimizing.

### When working with non-functional code

If you're integrating with libraries that don't use IO and expect direct execution, wrapping everything in IO can create friction. Sometimes it's better to work with the library's conventions and use IO at the boundaries.

## See Also

- [Task Monad](/docs/monads/task) - For lazy, memoized async operations
- [Try Monad](/docs/monads/try) - For exception handling
- [Reader Monad](/docs/monads/reader) - For dependency injection without side effects
