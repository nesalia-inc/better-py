---
title: Reader Monad
description: Dependency injection and environment management
---

# Reader Monad

The Reader monad provides a powerful way to handle dependencies and configuration in your code. Instead of passing dependencies through every function call manually, Reader lets you define computations that need access to some shared environment, then provide that environment all at once when you're ready to run the computation.

Think of Reader as a function waiting for its environment. When you create a Reader value, you're building a computation that says "I need a database connection to run" or "I need configuration to proceed," but you don't actually provide those dependencies yet. You're describing what you need, not when you need it. This separation of description and execution makes your code more testable, more flexible, and easier to reason about.

The Reader monad shines when you have multiple functions that all need access to the same dependencies. Rather than threading a database connection through five different function calls, each function declares what it needs using Reader, and you satisfy all those requirements with a single call at the end.

## When to Use Reader

Reader excels at dependency injection and configuration management. Here are the situations where it's most valuable:

<Callout type="success" title="Use Reader when:">

- **You need dependency injection**: Replace global variables or manual dependency passing with a clean, composable approach
- **Multiple functions share dependencies**: When several functions need access to the same database, logger, or configuration object
- **You want to make testing easier**: Swap real dependencies with mocks or fakes without changing your business logic
- **Configuration needs to flow through your application**: Provide config at the edge of your system and let it propagate automatically

</Callout>

The key insight is that Reader defers the question of "where do I get this dependency?" until later. You write your business logic assuming the dependency exists, then supply it at runtime.

## How Reader Works

Reader is essentially a wrapper around a function. When you create a Reader value, you're creating a function that takes an environment and returns a result. The monad operations let you compose these functions together, building up complex computations that all depend on the same environment.

Imagine you're writing code that needs a database connection. In traditional Python, you might write:

```python
def get_user(user_id: int, db: Database) -> User:
    return db.find(user_id)
```

This works, but now every function needs to receive `db` as a parameter. If you call functions that call other functions, you pass `db` down through the entire chain. With Reader, you write:

```python
def get_user(user_id: int) -> Reader[Database, User]:
    return Reader.ask().map(lambda db: db.find(user_id))
```

The function declares its dependency without receiving it. You compose these functions together, then provide the database once at the end. This is the essence of Reader: describing dependencies, then satisfying them.

## Creating Reader Values

Reader provides several ways to create values that depend on an environment. The most common approach is using `Reader.ask()`, which grabs the current environment and makes it available to your computation.

### Accessing the environment

When you need access to the shared environment, use `Reader.ask()`. This creates a Reader that extracts the environment so you can work with it:

```python
from better_py import Reader

def get_database_url() -> Reader[Config, str]:
    return Reader.ask().map(lambda config: config.db_url)

def get_api_key() -> Reader[Config, str]:
    return Reader.ask().map(lambda config: config.api_key)
```

Each of these functions says "I need a Config object, and I'll extract a specific value from it." The type annotation `Reader[Config, str]` means "this is a computation that needs a Config environment and produces a str result."

### Creating from functions

If you already have a function that takes your environment as input, you can wrap it directly using `Reader.from_fn()`:

```python
from better_py import Reader

def needs_config(config: Config) -> str:
    return config.api_key

reader = Reader.from_fn(needs_config)
# reader has type Reader[Config, str]
```

This is useful when you're refactoring existing code to use Reader. You can gradually wrap functions rather than rewriting them entirely.

## Working with Reader

Once you have Reader values, you'll want to combine them to build larger computations. Reader supports the standard monadic operations: `map` for transforming values, `bind` for chaining computations, and `tap` for performing side effects.

### Transforming values with map

Use `map()` when you want to transform the result of a Reader computation:

```python
from better_py import Reader

def get_user_id() -> Reader[Request, int]:
    return Reader.ask().map(lambda request: request.user_id)

# Transform the int to a User object
def get_user() -> Reader[Request, User]:
    return get_user_id().map(lambda id: User(id=id))
```

The `map` operation applies a function to the Reader's output without requiring additional dependencies. The environment stays the same throughout the transformation.

### Chaining computations with bind

When you need to sequence operations where later operations depend on earlier results, use `bind()` (also known as `and_then`):

```python
from better_py import Reader

def find_user(user_id: int) -> Reader[Database, User]:
    return Reader.ask().map(lambda db: db.find(user_id))

def get_user_profile(user: User) -> Reader[Database, Profile]:
    return Reader.ask().map(lambda db: db.get_profile(user.id))

# Chain them together
def get_full_profile(user_id: int) -> Reader[Database, Profile]:
    return find_user(user_id).bind(lambda user: get_user_profile(user))
```

Each step in the chain has access to the same Database environment, but the values flow from one computation to the next. This is how you build up complex workflows from simple, reusable pieces.

### Combining multiple dependencies

Sometimes your computation needs multiple independent pieces of data from the environment. You can combine Reader values using applicative operations:

```python
from better_py import Reader

def get_db_url() -> Reader[Config, str]:
    return Reader.ask().map(lambda c: c.db_url)

def get_api_key() -> Reader[Config, str]:
    return Reader.ask().map(lambda c: c.api_key)

# Combine both
def get_connection_info() -> Reader[Config, tuple[str, str]]:
    return get_db_url().ap(get_api_key()).map(
        lambda parts: (parts[1], parts[0])  # (api_key, db_url)
    )
```

The `ap` method lets you combine computations, gathering all the pieces you need before proceeding.

## Running Reader Computations

Building Reader computations is all about describing what you need. Running them is about providing what you've described. Use the `run()` method to supply your environment and execute the computation.

```python
from better_py import Reader

class Config:
    def __init__(self, db_url: str, api_key: str):
        self.db_url = db_url
        self.api_key = api_key

def get_api_key() -> Reader[Config, str]:
    return Reader.ask().map(lambda config: config.api_key)

# Build the computation
fetch_key = get_api_key()

# Run it with actual config
config = Config(db_url="postgresql://localhost", api_key="secret123")
key = fetch_key.run(config)
# key = "secret123"
```

The `run()` method takes your environment and passes it through the entire computation. This is where the dependency injection happens: you provide the real implementation, and Reader ensures it gets to every function that needs it.

## Real-World Patterns

### Dependency injection for services

Reader is particularly useful for injecting services like databases, loggers, and external APIs. Instead of creating global variables or passing dependencies manually, declare them with Reader:

```python
from better_py import Reader
from typing import TypeAlias

# Define your environment
Dependencies: TypeAlias = tuple[Database, Logger, Cache]

class Database:
    def find(self, id: int) -> User: ...

class Logger:
    def log(self, message: str) -> None: ...

class Cache:
    def get(self, key: str) -> Maybe[str]: ...

def fetch_user(user_id: int) -> Reader[Dependencies, User]:
    return (
        Reader.ask()
        .map(lambda deps: deps[0])  # Get Database
        .map(lambda db: db.find(user_id))
    )

def log_access(user_id: int) -> Reader[Dependencies, None]:
    return (
        Reader.ask()
        .map(lambda deps: deps[1])  # Get Logger
        .map(lambda logger: logger.log(f"User {user_id} accessed"))
    )

def get_user_with_logging(user_id: int) -> Reader[Dependencies, User]:
    return (
        fetch_user(user_id)
        .tap(lambda user: log_access(user_id))
    )

# At the edge of your application
deps = (Database(), Logger(), Cache())
user = get_user_with_logging(123).run(deps)
```

This approach keeps your business logic pure and testable. You can swap in fake dependencies for testing without changing any of the function implementations.

### Configuration management

Reader makes it easy to pass configuration through your application without threading it through every function manually:

```python
from better_py import Reader

class AppConfig:
    def __init__(self, database_url: str, api_key: str, debug: bool):
        self.database_url = database_url
        self.api_key = api_key
        self.debug = debug

def connect_to_database() -> Reader[AppConfig, Database]:
    return Reader.ask().map(lambda config: Database(config.database_url))

def create_api_client() -> Reader[AppConfig, ApiClient]:
    return Reader.ask().map(lambda config: ApiClient(config.api_key))

def initialize_app() -> Reader[AppConfig, tuple[Database, ApiClient]]:
    return (
        connect_to_database().ap(create_api_client())
        .map(lambda parts: (parts[1], parts[0]))
    )

# Provide config once at application startup
config = AppConfig(
    database_url="postgresql://localhost/mydb",
    api_key="sk-1234567890",
    debug=True
)
database, api = initialize_app().run(config)
```

Your business logic doesn't need to know where configuration comes from. It just declares what it needs, and you satisfy those requirements at the application boundary.

### Testing with mock dependencies

One of Reader's greatest strengths is how it simplifies testing. Since your functions declare their dependencies rather than receiving them directly, you can run the same code with different implementations:

```python
from better_py import Reader
import pytest

# Production code
def get_user(user_id: int) -> Reader[Database, User]:
    return Reader.ask().map(lambda db: db.find(user_id))

# Test code
class FakeDatabase:
    def __init__(self):
        self.users = {1: User(id=1, name="Alice"), 2: User(id=2, name="Bob")}

    def find(self, id: int) -> User:
        return self.users.get(id, User.null())

def test_get_user():
    fake_db = FakeDatabase()
    user = get_user(1).run(fake_db)
    assert user.name == "Alice"

def test_get_missing_user():
    fake_db = FakeDatabase()
    user = get_user(999).run(fake_db)
    assert user.is_null()
```

No mocking frameworks, no dependency injection containers, no global state. Just call `.run()` with a test implementation and verify the behavior.

## Common Mistakes

### Making environment too large

It's tempting to stuff everything into your Reader environment, but this makes your code harder to understand and test:

```python
# DON'T: Giant environment with everything
class AppEnvironment:
    database: Database
    logger: Logger
    cache: Cache
    config: Config
    request: Request
    session: Session
    # ... 20 more dependencies

def get_user(id: int) -> Reader[AppEnvironment, User]:
    ...

# DO: Use only what you need
def get_user(id: int) -> Reader[Database, User]:
    ...
```

Keep your environments focused. If different parts of your application need different dependencies, use different Reader types rather than one giant environment.

### Using Reader for simple cases

Not every function needs Reader. If you have a single function that takes a dependency, normal function parameters are clearer:

```python
# DON'T: Reader is overkill here
def get_user(id: int) -> Reader[Database, User]:
    return Reader.ask().map(lambda db: db.find(id))

# DO: Simple function is clearer
def get_user(id: int, db: Database) -> User:
    return db.find(id)
```

Reader shines when you're composing multiple operations that all need the same dependencies. For isolated operations, regular parameters are more straightforward.

### Unnecessary ask() calls

You don't need to call `Reader.ask()` for every operation. Once you have the environment, you can work with it directly:

```python
# DON'T: Repeated ask() calls
def get_user_and_profile(id: int) -> Reader[Database, tuple[User, Profile]]:
    user = Reader.ask().map(lambda db: db.find_user(id))
    profile = Reader.ask().map(lambda db: db.get_profile(id))
    return user.ap(profile)

# DO: Ask once, use the result
def get_user_and_profile(id: int) -> Reader[Database, tuple[User, Profile]]:
    return (
        Reader.ask()
        .map(lambda db: (db.find_user(id), db.get_profile(id)))
    )
```

## When NOT to Use Reader

Reader is a powerful tool, but it's not always the right choice. Here are situations where you should consider alternatives:

### For single-use dependencies

If a dependency is only used in one place and never shared, just pass it as a regular parameter. Reader adds complexity without benefit when you're not composing multiple dependent operations.

### For highly performance-critical code

Reader does introduce a small overhead from function wrapping and deferred execution. In tight loops or performance-critical sections, direct dependency passing may be faster. Profile your code to see if this matters for your use case.

### When working with non-functional code

If you're integrating with libraries that don't use Reader and expect their dependencies as parameters, wrapping everything in Reader can create friction. Sometimes it's better to work with the library's conventions rather than forcing everything into a functional style.

## See Also

- [State Monad](/docs/monads/state) - For managing state transitions in pure functions
- [IO Monad](/docs/monads/io) - For managing side effects explicitly
- [State Management Guide](/docs/guides/state-management) - Patterns for managing application state
