---
title: Writer Monad
description: Log computations and accumulate values
---

# Writer Monad

The **Writer** monad represents computations that produce a value along with a log or accumulator. It's useful for logging, tracking, and accumulating values through a chain of operations.

## Overview

`Writer[W, A]` contains:
- A **value** of type `A` (the computation result)
- A **log** of type `W` (accumulated output)

The log type `W` must be a monoid (support combining and identity):
- Built-in monoids: `list`, `str`, `int`, `float`, `set`
- Custom monoids: Implement the `Monoid` protocol

## Creating Writer Values

### Using the Generic Constructor

```python
from better_py import Writer

# Create with list log
writer = Writer(["log1", "log2"], 42)
writer.tell()  # (["log1", "log2"], 42)

# Create with string log
writer = Writer("Step 1: ", "result")
writer.tell()  # ("Step 1: ", "result")
```

### Using Convenience Functions

```python
from better_py import list_writer, str_writer, sum_writer

# List writer (concatenation)
list_writer([1, 2], "a").tell()  # ([1, 2], "a")

# String writer (concatenation)
str_writer("hello ", "world").tell()  # ("hello ", "world")

# Sum writer (addition)
sum_writer(5, "result").tell()  # (5, "result")
```

### `Writer.tell_log(log)` - Log Without a Value

```python
from better_py import Writer

Writer.tell_log(["debug message"]).tell()  # (["debug message"], None)
```

## Extracting Values

### `tell()` - Extract Log and Value

```python
from better_py import Writer

writer = Writer(["log1", "log2"], 42)
log, value = writer.tell()
log    # ["log1", "log2"]
value  # 42
```

## Transforming Writer

### `map(f)` - Transform the Value

```python
from better_py import Writer

writer = Writer(["log"], 5)
mapped = writer.map(lambda x: x * 2)
mapped.tell()  # (["log"], 10)
```

### `flat_map(f)` - Chain Writer Operations (Accumulates Logs)

```python
from better_py import Writer

def step1(x):
    return Writer(["step1"], x + 1)

def step2(x):
    return Writer(["step2"], x * 2)

writer = Writer(["init"], 5)
result = writer.flat_map(step1).flat_map(step2)
result.tell()  # (["init", "step1", "step2"], 12)
```

## Advanced Operations

### `listen()` - Extract Log and Value as Pair

```python
from better_py import Writer

writer = Writer(["log"], 42)
listened = writer.listen()
listened.tell()  # ((["log"], 42), ["log"])
```

### `pass_()` - Pass the Log Through

```python
from better_py import Writer

writer = Writer(["log"], 42)
passed = writer.pass_()
passed.tell()  # (["log"], ["log"])
```

## Real-World Examples

### Function Logging

```python
from better_py import list_writer

def process_user(user_id: int):
    return (list_writer([f"Fetching user {user_id}"], None)
        .map(lambda _: fetch_user(user_id))
        .flat_map(lambda user: list_writer([f"User found: {user['name']}"], user)))

result = process_user(1)
log, value = result.tell()
# log: ["Fetching user 1", "User found: Alice"]
# value: {"id": 1, "name": "Alice"}
```

### Audit Trail

```python
from better_py import str_writer

def transfer_money(from_account: int, to_account: int, amount: float):
    return (str_writer(f"Validating transfer of ${amount} from {from_account} to {to_account}\n", None)
        .map(lambda _: validate_accounts(from_account, to_account))
        .flat_map(lambda _: str_writer(f"Transfer validated\n", amount))
        .flat_map(lambda _: str_writer(f"Executing transfer\n", execute_transfer(from_account, to_account, amount)))
        .map(lambda _: str_writer(f"Transfer complete\n", None)))

result = transfer_money(1, 2, 100.0)
log, _ = result.tell()
# log:
# Validating transfer of $100.0 from 1 to 2
# Transfer validated
# Executing transfer
# Transfer complete
```

### Calculation with Steps

```python
from better_py import list_writer

def add(x, y):
    return list_writer([f"Adding {x} + {y}"], x + y)

def multiply(x, y):
    return list_writer([f"Multiplying {x} * {y}"], x * y)

def calculate(a, b, c):
    return (add(a, b)
        .flat_map(lambda sum_result: multiply(sum_result, c)))

result = calculate(5, 3, 2)
log, value = result.tell()
# log: ["Adding 5 + 3", "Multiplying 8 * 2"]
# value: 16
```

### String Building

```python
from better_py import str_writer

def build_paragraph(name: str, age: int):
    return (str_writer(f"Name: {name}, ", None)
        .map(lambda _: str_writer(f"Age: {age}", None))
        .map(lambda _: str_writer(". ", None)))

result = build_paragraph("Alice", 30)
log, _ = result.tell()
# log: "Name: Alice, Age: 30. "
```

### Counter/Tally

```python
from better_py import sum_writer

def count_items(items: list):
    def count_rec(remaining):
        if not remaining:
            return sum_writer(0, 0)
        return sum_writer(1, None).map(lambda _: count_rec(remaining[1:]).map(lambda c: c + 1))

    return count_rec(items)

result = count_items([1, 2, 3, 4, 5])
log, value = result.tell()
# log: 5 (number of items)
# value: 5
```

## Custom Monoids

You can use custom types as logs by implementing the `Monoid` protocol:

```python
from better_py import Writer, Monoid
from dataclasses import dataclass

@dataclass
class LogEntry:
    level: str
    message: str

    def combine(self, other: "LogEntry") -> "LogEntry":
        return LogEntry(
            level=self.level,
            message=f"{self.message}; {other.message}"
        )

    @staticmethod
    def identity() -> "LogEntry":
        return LogEntry(level="INFO", message="")

# Use with Writer
writer = Writer(LogEntry("INFO", "Step 1"), "result")
```

## When to Use Writer

Use **Writer** when:
- You need to log computations
- You want to accumulate values
- You need audit trails
- You're building debug/trace systems
- You want to track computation steps

**Don't use Writer** when:
- You only need the result (use plain functions)
- Logging is handled externally
- You need different log types per operation

## See Also

- [IO](/docs/monads/io) - For side effect management
- [State](/docs/monads/state) - For state threading
- [Reader](/docs/monads/reader) - For dependency injection
