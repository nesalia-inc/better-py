---
title: Compose
description: Function composition and building complex transformations
---

Function **composition** is one of the most fundamental concepts in functional programming. It's the process of combining simple functions to build more complex ones, where the output of one function becomes the input of the next. The `compose` utilities bring this powerful concept to Python in a way that's both practical and intuitive.

## The Mathematical Foundation

In mathematics, function composition is denoted as (f ∘ g)(x) = f(g(x)). The compose functions follow this convention—functions are applied **right to left**. This might feel backwards at first, but it matches how mathematicians have thought about functions for centuries.

Why right to left? Think of it as "nesting" function calls:

```python
# These are equivalent:
result = compose(f, g, h)(x)      # Compose style
result = f(g(h(x)))                 # Traditional style
```

The rightmost function (`h`) is applied first, then `g`, then `f`. This ordering makes compose equivalent to function nesting, which helps with reasoning about function behavior.

## Why Composition Matters

Composition changes how you think about building software. Instead of writing large, monolithic functions that do everything, you write small, focused functions and compose them together. This has profound benefits:

- **Testability**: Small functions are easier to test than large ones
- **Reusability**: Composable functions can be reused in different contexts
- **Readability**: Well-named composed functions read like sentences
- **Maintainability**: Changes are localized to specific functions

Consider user registration. Instead of one giant function:

```python
def register_user(username, email, password):
    # 50 lines of validation, database calls, email sending...
```

You compose focused functions:

```python
register_user = compose(
    send_welcome_email,
    create_database_record,
    validate_password,
    validate_email,
    validate_username
)
```

Now each validation can be tested independently, and the registration flow is crystal clear.

## Understanding `compose`

The `compose` function creates a new function that applies its arguments right to left. This is particularly useful when you want to create reusable function combinations.

### Building Transformation Pipelines

Think of compose as building a processing pipeline where data flows from right to left. The rightmost function is the first transformation, and each subsequent function refines the result further.

For example, in natural language processing:

```python
from better_py.functions import compose

# Build a text processing pipeline
process_text = compose(
    capitalize_sentences,
    fix_grammar,
    remove_stopwords,
    tokenize,
    lowercase
)
```

When you apply `process_text(text)`, the text is lowercased first, then tokenized, then stopword removal happens, etc. Each function is a lens that focuses the transformation, and compose brings them together into a cohesive whole.

### Type Safety and Composition

One of the beautiful aspects of function composition is how it works with types. If you have functions `f: B → C` and `g: A → B`, then `compose(f, g): A → C`. The types line up perfectly—the output type of one function matches the input type of the next.

This is why composed functions feel so natural to write—the types guide you. If you try to compose functions with mismatched types, you'll know immediately when you try to use the result.

## Understanding `compose_left`

The `compose_left` function is `compose`'s mirror image—functions are applied **left to right**. This is actually the same as `pipe`, but returns a function instead of executing immediately.

Why have both? It's about your mental model and what you're trying to express:

- Use `compose` when thinking mathematically (building transformations)
- Use `compose_left` when thinking procedurally (processing steps)

```python
# Mathematical: building a transformation
transform = compose(square, double, increment)

# Procedural: defining a process
process = compose_left(step1, step2, step3)
```

Both create functions, but they emphasize different aspects of your intent.

## The Power of Point-Free Style

Composition enables **point-free style**, where you don't explicitly name arguments. Instead of saying "take x and apply f, g, h to it," you just say "compose f, g, h."

```python
# With explicit argument
def process(x):
    return h(g(f(x)))

# Point-free style
process = compose(h, g, f)
```

Point-free style is controversial—some love its elegance, others find it obscure. The key is to use it when it improves clarity. Point-free shines when the composition itself tells the story:

```python
# Clear and intent-revealing
fetch_and_process = compose(process_data, fetch_resource)

# Less clear
def operation(x):
    return process_data(fetch_resource(x))
```

## Common Patterns

### Validation Chaining

Composed functions excel at multi-step validation where each step validates something specific:

```python
from better_py.functions import compose

validate_user = compose(
    check_not_banned,
    check_is_active,
    check_exists,
    get_user
)
```

The composition reads like a checklist: "get the user, check if they exist, check if active, check if not banned." If any check fails, the composition short-circuits (assuming the validation functions return Result or Maybe types).

### Data Transformation Builders

In data engineering, you often build complex transformations from simple primitives:

```python
from better_py.functions import compose

# Build a data pipeline
pipeline = compose(
    aggregate_metrics,
    group_by_category,
    normalize_data,
    extract_fields,
    parse_json
)
```

Each step is a clear transformation, and the pipeline is a reusable asset. Different teams can use the same pipeline on different data sources.

### Middleware and Decorator Chains

Web frameworks use composition heavily for middleware chains:

```python
from better_py.functions import compose

# Build request handler from middleware
handle_request = compose(
    send_response,
    add_security_headers,
    log_request,
    authenticate,
    rate_limit
)
```

Each middleware wraps the next, creating an onion-like structure. Composition makes this elegant rather than nested and confusing.

## Compose vs. Pipe: Which to Choose?

The choice often comes down to reusability and mental model:

| Aspect | `compose` | `pipe` |
|--------|-----------|--------|
| **Returns** | Function | Value |
| **Use when** | Building reusable transformations | One-time data processing |
| **Mental model** | Mathematical, structural | Procedural, operational |
| **Best for** | Libraries, frameworks, utilities | Scripts, data processing |

Think of it this way: `compose` creates a tool, `pipe` uses the tool.

```python
# Create a reusable tool
process = compose(clean, transform, validate)

# Use the tool immediately
pipe(data, process)

# Or use it multiple times
processed_data1 = process(data1)
processed_data2 = process(data2)
```

## Real-World Examples

### Financial Calculations

In financial applications, calculations often involve multiple steps that need to be composed:

```python
from better_py.functions import compose

# Build a pricing calculator
calculate_price = compose(
    apply_tax,
    apply_discount,
    calculate_shipping,
    get_base_price
)

price = calculate_price(order)
```

Each step is independent and can be changed without affecting others. Need to change the tax rate? Update `apply_tax`. Need free shipping? Modify `calculate_shipping`.

### Image Processing Pipeline

Image processing naturally composes—each filter or transformation is a function:

```python
from better_py.functions import compose

# Build an image enhancement pipeline
enhance_image = compose(
    save_image,
    sharpen,
    adjust_contrast,
    denoise,
    load_image
)
```

The pipeline reads like a recipe and can be reused on any image. You can create different pipelines for different purposes (portrait enhancement, landscape enhancement, etc.).

### Data Science Workflows

Data science workflows involve many steps—data loading, cleaning, feature engineering, modeling, evaluation:

```python
from better_py.functions import compose

# Build a complete ML pipeline
train_model = compose(
    evaluate,
    train,
    feature_engineer,
    clean_data,
    load_dataset
)
```

Each step can be swapped out for experimentation without changing the overall structure.

## Testing Composed Functions

Composed functions are testable at multiple levels:

```python
# Test individual functions
def test_lowercase():
    assert lowercase("HELLO") == "hello"

# Test the composition
def test_process_text():
    assert process_text("HELLO") == "hello"  # simplified

# Test in different contexts
def test_process_text_with_punctuation():
    assert process_text("HELLO!") == "hello!"
```

This layered testing gives you confidence that each part works and that they work together correctly.

## Performance Considerations

Each function call in a composition has overhead. For most applications, this overhead is negligible. However, in tight loops or performance-critical code, you might need to inline or manually optimize composed functions.

Remember that premature optimization is the root of much evil. Profile before optimizing—you'll often find that the function composition overhead isn't your bottleneck.

## Common Pitfalls

### Function Order Errors

It's easy to get the order wrong, especially with compose's right-to-left application:

```python
# Common mistake: wrong order
bad = compose(f, g, h)  # Applies h, then g, then f

# Intended order
good = compose(h, g, f)  # Applies f, then g, then h
```

Test your composed functions to ensure they apply in the order you expect.

### Type Mismatches

Composition requires that output types match input types:

```python
# This will fail: g returns str, f expects int
f = lambda x: x + 1        # int -> int
g = lambda x: str(x)       # int -> str
bad_compose = compose(f, g)  # Type error!
```

Python won't catch this at compile time, but you'll get runtime errors when you try to use the composed function.

## When to Use Compose

Use **compose** when:
- Building reusable function combinations
- Creating libraries and frameworks
- Following mathematical conventions
- Need to pass composed functions as values
- Emphasizing transformation over execution

Use **compose_left** when:
- Want left-to-right reading order
- Building procedural pipelines
- Need reusable pipe-like functions

## See Also

- [pipe & flow](/docs/functions/pipe) - For left-to-right data flow
- [curry](/docs/functions/curry) - For partial application
- [monads](/docs/monads) - For context-aware composition
